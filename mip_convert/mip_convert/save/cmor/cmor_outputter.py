# (C) British Crown Copyright 2009-2025, Met Office.
# Please see LICENSE.md for license details.
"""
Module contains classes to output variables through CMOR.

Clients of the classes and functions in this module should only need
to know about the CmorOutputterFactory and CmorOutputter.  The basic
idea is that each variable to be output will have its own
CmorOutputter, this CmorOutputter can be generated by a call to the
CmorOutputterFactory, with the relevent arguments (see the class
documentation).

Other important concepts that are represented by classes in this
module include a CmorDomain and an AxisMaker.  See the documentation
of the relevant factory classes L{CmorDomainFactory} and
L{AxisMakerFactory} for more information on what these concepts are
supposed to represent.

Some implementation notes:

   1. Many of the class constructors have a cmor or cmor_wrapper
      object is input parameters.  This makes testing of the classes
      easier, as test cases do not need to interact with a live CMOR
      installation (producing files etc), but can use a stub object.

   2. I think the design has some issues.  I suspect there are too
      many classes and the classes that exist are not quite expressing
      the right object model.

   3. Some of the interface was evolved
      from a system that suppored both output through CMOR and output
      through CDAT methods.  Although the second of these has been
      retired there are still some things that are there because of
      the history.  In time they may be refactored out.
"""
from copy import copy
import os.path

from mip_convert import mip_parser
import mip_convert.common
from mip_convert.common import RelativePathChecker
from mip_convert.save.mip_config import MipTableFactory


TIME_TYPE = mip_convert.common.TIME_TYPE
SITE_TYPE = mip_convert.common.SITE_TYPE
REFTIME_TYPE = mip_convert.common.REFTIME_TYPE


class CmorOutputError(Exception):
    """
    A class to represent errors
    associated with the classes responsible for interacting with the
    CMOR API.  Note that the CMOR API has its own error handling that
    is completely independent of this.
    """
    pass


class MoNameSpace(object):
    """
    Holds intellegence on NetCDF attribute names and values for a
    Met Office use of CMOR output files.  This class simply isolates
    this in one place.

    It is not particularly clever, but keeps it altogether.
    """
    namespace_id = 'mo'

    RUNID = '%s_runid' % namespace_id

    def original_name(self, variable):
        """
        return a string suitable for a cmor variable original_name attribute

        This simply takes the stash_history attribute of the variable
        and prepends the name space identifier.
        The policy on what goes in stash_history should be dealt
        with elsewhere in the input and processing chain producing variable.

        @param variable: the variable
        @return: a string with the original_name of the variable
        """
        return self.namespace_stamp(variable.stash_history)

    def namespace_stamp(self, astring):
        return '%s: %s' % (self.namespace_id, astring)


class EndOfMultipleYears(object):
    """
    Used to discover whether two dates lie either side of a year, pentade or
    decade end.
    """

    def __init__(self, value):
        self._value = value

    def outside(self, date1, date2):
        return date1.year == date2.year or (date2.year - 1) % self._value != 0


class SeasonalDecade(object):
    """
    A naive implementation for determining whether two dates contain
    the seasonal decadal baoundary as defined by CORDEX - DJF xx99 is a new
    decade.
    """
    _MONS = (1, 4, 7, 10)
    _YEAR_BOUNDARY = 0

    def outside(self, date1, date2):
        if self._not_seasonal_interval(date1, date2):
            raise CmorOutputError()
        return self._seasonal_boundary(date1)

    def _seasonal_boundary(self, date1):
        return date1.year % 10 != self._YEAR_BOUNDARY or date1.month != self._MONS[-1]

    def _not_seasonal_interval(self, date1, date2):
        return not self._seasonal_month(date1) or not self._seasonal_month(date2)

    def _seasonal_month(self, date):
        return date.month in self._MONS


class MipTableVariable(object):
    # TODO: refactor to inline CmorDomainFactory, AxisMakerFactory,
    # saverFactory
    _CORDEX_MAP = {'3h': EndOfMultipleYears(1),
                   '6h': EndOfMultipleYears(1),
                   'mon': EndOfMultipleYears(10),
                   'day': EndOfMultipleYears(5),
                   'sem': SeasonalDecade()}  # hard code for now

    def __init__(self, table, entry, domain_factory):
        """
        return an object that can coordinate the generation of
        cmor axis ids

        table - table name
        entry - the variable entry
        domain_factory - object that can generate domains
        """
        self.table = table
        self.entry = entry
        self._domain = domain_factory.getCmorDomain(self.table, self.entry)

    def has_time(self):
        return self._domain.has_time()

    def getAxisIds(self, variable):
        return self._domain.getAxisIds(variable)

    def boundary_finder(self):
        # this hard codes based on the table name alternatives would be to use the approx interval in the MIP table?
        return self._CORDEX_MAP[self._table_name()]

    def use_cordex_chunking(self):
        """returns True if the request uses CORDEX chunking scheme"""
        # not brilliant - hard coded
        result = not self.table.endswith('fx')
        result = result and self.table.startswith('CORDEX') or self.table.startswith('NILE2')
        return result

    def _table_name(self):
        """returns the table name of the mip table"""
        return self.table.split('_')[-1]


def saverFactory(tablepath, acmor):
    """
    tablepath: path to MIP tables
    acmor: cmor that has had setup and dataset defined
    """
    rel_path = RelativePathChecker(tablepath, MipTableFactory.TABLE, os.path)
    return CmorSaverFactory(CmorDomainFactory(MipTableFactory(mip_parser, rel_path)), acmor)


class CmorSaverFactory(object):
    def __init__(self, domain_factory, cmor):
        """
        @param domain_factory: object that can be used to generate domains
        @param cmor: the cmor object to use in CMOR API calls
        """
        self.cmor = cmor
        self.domain_factory = domain_factory
        self.domain_factory.cmor = self.cmor

    def getSaver(self, table, entry, outputs_per_file=None):
        """
        return object that will deal with output for var_request
        """
        entry = MipTableVariable(table, entry, self.domain_factory)

        if outputs_per_file is not None:
            return MultiFileOutputter(entry, outputs_per_file, self.cmor)
        else:
            return SingleFileOutputter(entry, self.cmor)


class AbstractCmorOutputter(object):
    """
    Deal with outputing variables through CMOR.
    This is an abstract class.  Subclasses should provide their
    own write_var method.  The class provides methods that can be used by
    sub classes, e.g. to find variable ids, and axis ids.

    Use one Outputter per requested variable.
    """

    def __init__(self, entry, cmor_wrapper):
        self.cmor = cmor_wrapper
        self.entry = entry
        self._name_space = MoNameSpace()
        self.varid = None

    def write_var(self, variable):
        """
        write a variable using CMOR

        @param variable: the variable to be written
        @raises CmorExceptionError: if the variable has longer time axis than allowed in a file
        """
        raise NotImplementedError('method on abstract class')

    def __call__(self, variable):
        self.write_var(variable)

    def _write_var(self, variable):
        if self.entry.has_time():
            axis_args = axisKeyWords(variable.time(), ('time_vals', 'time_bnds'))
        else:
            axis_args = {}
        var_id = self._getVarId(variable)

        # Both variable.deflate_level and variable.shuffle may be None.
        if variable.deflate_level:
            enable_deflation = True
            deflate_level = variable.deflate_level
        else:
            enable_deflation = False
            deflate_level = 0
        if variable.shuffle:
            shuffle = True
        else:
            shuffle = False

        self.cmor.set_deflate(var_id, shuffle, enable_deflation, deflate_level)

        # Add the 'MIP requested variable name' to the global attributes to help with identification,
        # i.e. when the 'out_name' is different to the 'variable_entry' in the 'MIP table'.
        self.cmor.set_cur_dataset_attribute('variable_name', self.entry.entry)

        self.cmor.write(var_id, variable.getValue(), **axis_args)

    def _need_new_varid(self):
        return self.varid is None

    def _getVarId(self, variable):
        """
        return the CMOR variable ID for this variable

        the call to cmor.variable is done only once, the first
        time this method is called.
        """
        self.cmor.load_table(self.entry.table)  # always needs to happen
        if self._need_new_varid():
            self._makeVarid(variable)
        return self.varid

    def _makeVarid(self, variable):
        axis_ids = self.entry.getAxisIds(variable)
        self.varid = self.cmor.variable(self.entry.entry,
                                        variable.units,
                                        axis_ids,
                                        original_name=self._name_space.original_name(variable),
                                        data_type=variable.missing_value_type,
                                        missing_value=variable.missing_value,
                                        positive=variable.positive,
                                        history=variable.history,
                                        **self._optional_kwargs(variable))

    def _optional_kwargs(self, variable):
        kwargs = dict()
        if hasattr(variable, 'comment'):
            kwargs['comment'] = self._name_space.namespace_stamp(variable.comment)
        return kwargs

    def _close_file(self):
        self.cmor.close(self.varid, preserve=True)


class SingleFileOutputter(AbstractCmorOutputter):
    """
    Outputters of that are instances of this class will write to a
    single CMOR file.
    """

    def write_var(self, variable):
        """
        write variable to output

        see L{AbstractCmorDomain}
        """
        self._write_var(variable)


class ChunkLen(object):
    """
    Class to contain the chunk length (time axis dimension length) of a variable.

    Deals with initialisation of the chunk length and basic comparison
    """

    def __init__(self):
        self._initialised = False

    def __str__(self):
        return str(self._len)

    def _init(self, chunk_len):
        if not self._initialised:
            self._initialised = True
            self._len = chunk_len

    def as_expected(self, time_len):
        self._init(time_len)
        return self._len == time_len


class MultiFileOutputter(AbstractCmorOutputter):
    """
    Outputters of that are instances of this class will write to a
    sequence of files.
    """

    FACTOR_MSG = 'time axis length (%s) not an exact factor of number of output times (%s)'
    CHANGE_MSG = 'Looks like the variable chunk time length has changed from %s to %s'

    def __init__(self, entry, times_per_file, cmor_wrapper):
        """
        Each file will contain ntimes_per_file output times.  The parameters
        are the same as those for L{AbstractCmorOutputter} with the additional:

        @param times_per_file: the number of times to be written to each output file.
        """
        super(MultiFileOutputter, self).__init__(entry, cmor_wrapper)
        self._ntimes_per_file = times_per_file
        self._reset_time_counter()
        self._expected_chunk = ChunkLen()

    def _reset_time_counter(self):
        self._ntimes_current_file = 0

    def _increment_time_counter(self, variable):
        self._ntimes_current_file = self._ntimes_current_file + len(variable.time())

    def _is_file_complete(self):
        return self._ntimes_current_file == self._ntimes_per_file

    def _check_len(self, variable):
        """
        Raise an exception if the variable time dimension length looks problematic

        Naive checks on the variables to ensure that the outputs_per_file is compatible
        with the input variable time length, and the length is constant between calls.
        """
        self._check_len_multiple(len(variable.time()))
        self._check_len_unchanged(len(variable.time()))

    def _check_len_multiple(self, time_len):
        if self._ntimes_per_file % time_len != 0:
            raise CmorOutputError(self.FACTOR_MSG % (time_len, self._ntimes_per_file))

    def _check_len_unchanged(self, time_len):
        if not self._expected_chunk.as_expected(time_len):
            raise CmorOutputError(self.CHANGE_MSG % (self._expected_chunk, time_len))

    def write_var(self, variable):
        """
        write variable to output

        see L{AbstractCmorDomain}
        """
        self._check_len(variable)
        if self._is_file_complete():
            self._close_file()
            self._reset_time_counter()
        self._write_var(variable)
        self._increment_time_counter(variable)


class NotWrittenAxis(object):
    """
    A special type class to start a series of output
    """

    @staticmethod
    def continues_period(other, period):
        return True


class PeriodWriter(AbstractCmorOutputter):
    """
    Instances of this class deal with the outputting to files in chunks
    determined by a period.  This is in support of CORDEX output.
    """

    def __init__(self, entry, cmor, period):
        """
        entry - the mip table entry
        cmor - object with cmor interface
        period - object that determines whether a time period has a boundary
                 between two times.
        """
        super(PeriodWriter, self).__init__(entry, cmor)
        self.last_axis = NotWrittenAxis()
        self._period = period

    def set_last_written(self, time):
        self.last_axis = time

    def should_close(self, time):
        return not self.last_axis.continues_period(time, self._period)

    def write_var(self, variable):
        # this can be simplified - but leave for now. This has a simplified functionality - which works for CORDEX,
        # but may be limited for other cases. It assumes there is only one end of period in the variable to be output.
        if self.should_close(variable.time()):
            self._close_file()

        if variable.time().contains_end_of_period(self._period):
            self._write_var(variable.time_slice(variable.time().pre_period_break(self._period)))
            self._close_file()
            self._write_var(variable.time_slice(variable.time().post_period_break(self._period)))
        else:
            self._write_var(variable)
        self.set_last_written(variable.time())


class CmorDomainFactory(object):
    """
    A call to cmor.variable needs a set of axis ids to be passed as arguments,
    the axis ids depend on the domain of the variable as expected by the MIP
    tables.  The domain might be lat-lon-time, lat-lon-height-time.  This
    expected domain is defined in the MIP tables.
    The CmorDomain classes provide the axis_ids for a variable given its
    MIP table and variable_entry.  Different CmorDomains are needed
    for different physical domains (e.g. whether height is present or not).
    The CmorDomainFactory is responsible for
    creating a CmorDomain, depending on the variable_entry in the MIP table.
    """

    def __init__(self, table_factory):
        """
        return the CmorDomainFactory using the MIP table represented
        by the table_factory

        @param table_factory: an object capable of producing MIP tables
        @type table_factory: L{mip_convert.save.mip_config.MipTableFactory}
        """
        self.table_factory = table_factory

    def _getTable(self, table_name):
        return self.table_factory.getTable(table_name)

    def getCmorDomain(self, table_name, variable_entry):
        """
        return the relevant CmorDomain for the variable_entry in table_name
        @param table_name: the table id (string... format..?)
        @param variable_entry: the variable_entry in the table that the domain is needed for
        """
        table = self._getTable(table_name)
        if not table.hasVariable(variable_entry):
            raise CmorOutputError('variable "%s" not in table "%s"' % (variable_entry, table_name))
        mip_variable = table.getVariable(variable_entry)
        return CmorDomain(AxisMakerFactory(table, mip_variable, self.cmor))


class CmorStandardGridMaker(object):
    """
    Instances of this class deal with the creation of the 'grid' for a
    standard latitude-longitude field.

    In practice there is little to do as CMOR doesn't need a 'grid' for
    this type of field.
    """

    def grid_define(self, variable, ids):
        pass

    def correct_horizontal_ids(self, axis_ids, axis_dirs):
        result = list()
        for axis_index, _ in enumerate(axis_dirs):
            result.append(axis_ids[axis_index])
        return result


class CmorGridMaker(object):
    """
    Instances of this class deal with the creation of a grid; tripolar
    and rotated pole grid are supported.
    """
    _GRID_CACHE = dict()

    def __init__(self, axis_maker_factory):
        """
        Create a grid maker.

        A side effect of this constructor is it will set the grid table
        as required for cmor.
        """
        self._axis_maker_factory = axis_maker_factory
        self._set_table_for_variable_axes()
        self.grid_id = None

    def grid_define(self, variable, ids):
        """
        Define the grid id and grid parameters.
        """
        self._define_grid(ids, variable.domain)
        self._reset_table()

    def correct_horizontal_ids(self, axis_ids, axis_dirs):
        """
        Replace the horizontal axis ids with the grid id.
        """
        result = list()
        grid_assigned = False

        for axis_index, axis_dir in enumerate(axis_dirs):
            if self._axis_maker_factory.is_horizontal(axis_dir):
                if not grid_assigned:
                    result.append(self.grid_id)
                    grid_assigned = True
            else:
                result.append(axis_ids[axis_index])

        return result

    def _set_table_for_variable_axes(self):
        self._axis_maker_factory.use_grid_table()

    def _cache_key(self, horizontal_axis_ids):
        return tuple(horizontal_axis_ids)

    def _define_grid(self, horizontal_axis_ids, domain):
        """
        Sets the grid_id for this set of horizontal_axis and domain.

        The grid_id is cached to reduce the number of calls to cmor grid.
        """
        unique_key = copy(horizontal_axis_ids)
        unique_key.append(domain.fingerprint)
        if self._cache_key(unique_key) not in CmorGridMaker._GRID_CACHE:
            CmorGridMaker._GRID_CACHE[self._cache_key(unique_key)] = (self._grid(horizontal_axis_ids, domain))

        self.grid_id = CmorGridMaker._GRID_CACHE[self._cache_key(unique_key)]

    def _grid(self, horizontal_axis_ids, domain):
        """
        Create the CMOR grid with the relevant mapping information.
        """
        grid_id = self._axis_maker_factory.grid(horizontal_axis_ids, domain)
        if domain.is_rotated:
            self._axis_maker_factory.set_grid_mapping(grid_id, *domain.grid_mapping)
        return grid_id

    def _reset_table(self):
        self._axis_maker_factory.reset_table()


class CmorDomain(object):

    def __init__(self, axis_maker_factory):
        """
        @param axis_maker_factory: object used to generate axis makers for this domain
        @type axis_maker_factory: L{AxisMakerFactory}
        """
        self.axis_maker_factory = axis_maker_factory
        self.axis_ids = dict()
        self.grid_maker = None

    def getAxisIds(self, variable):
        """
        assign cmor axis ids for each of the axis of the variable
        the ids are returned in the order of the axes of the variable
        @param variable: the variable that will be output through CMOR
        @type variable: L{mip_convert.variable.Variable}

        @raises CmorOutputError: if variable can not use this domain class
        """
        self._make_horizontal_axes(variable)
        self._make_non_spatial_axes(variable)
        self._make_z_axis(variable)
        return self._ids_in_data_order(variable)

    def has_time(self):
        return self.axis_maker_factory.has_time()

    def _set_grid_maker(self, variable):
        if variable.is_rotated or variable.is_tripolar:
            self.grid_maker = CmorGridMaker(self.axis_maker_factory)
        else:
            self.grid_maker = CmorStandardGridMaker()

    def _make_horizontal_axes(self, variable):
        self._set_grid_maker(variable)
        self._make_horizontal_ids(variable)
        self.grid_maker.grid_define(variable, self._my_horizontal_ids(variable))

    def _make_z_axis(self, variable):  # move to maker?
        for axis_dir in self.axis_maker_factory.z_axis():
            maker = self._get_maker(axis_dir, variable)
            maker.set_horizontal(self._my_horizontal_ids(variable))
            self.axis_ids[axis_dir] = maker.cmorId()

    def _make_non_spatial_axes(self, variable):
        self._make_axes(variable, self._non_spatial_dir(variable))

    def _make_horizontal_ids(self, variable):
        self._make_axes(variable, self._horizontal_dir(variable))

    def _make_axes(self, variable, axis_dirs):  # move to maker?
        for axis_dir in axis_dirs:
            maker = self._get_maker(axis_dir, variable)
            self.axis_ids[axis_dir] = maker.cmorId()

    def _my_horizontal_ids(self, variable):
        result = list()
        for axis_dir in self._horizontal_dir(variable):
            result.append(self.axis_ids[axis_dir])
        return result

    def _non_spatial_dir(self, variable):
        return [axis_dir for axis_dir in self.axis_maker_factory.non_spatial_axes()
                if axis_dir in variable.getAxisOrder()]

    def _is_horizontal(self, axis_dir):
        return self.axis_maker_factory.is_horizontal(axis_dir)

    def _horizontal_dir(self, variable):
        """returns the horizontal axis directions in data order"""
        # should this be a method on variable?
        return [axis_dir for axis_dir in variable.getAxisOrder() if self._is_horizontal(axis_dir)]

    def _axis_ids_in_data_order(self, variable):
        result = list()
        for axis_dir in self._mip_axes_in_var_order(variable):
            result.append(self.axis_ids[axis_dir])
        return result

    def _ids_in_data_order(self, variable):
        """
        return the axis ids in the order they are present in the data array
        """
        axis_ids = self._axis_ids_in_data_order(variable)
        return self.grid_maker.correct_horizontal_ids(axis_ids, self._mip_axes_in_var_order(variable))

    def _mip_axes_in_var_order(self, variable):
        result = list()
        for axis_dir in variable.getAxisOrder():
            if not self.axis_maker_factory.has_axis(axis_dir):
                self._check_scalar(variable.getAxis(axis_dir))
            else:
                result.append(axis_dir)
        return result

    def _get_maker(self, axis_dir, variable):
        """
        @return: the axis maker for the variable axis in direction axis_dir
        """
        return self.axis_maker_factory.getAxisMaker(axis_dir, variable)

    @staticmethod
    def _check_scalar(axis):
        if not axis.is_scalar:
            raise CmorOutputError('attempt to ignore non scalar axis - select a single level')


def axisKeyWords(axis, keys):
    """
    prepares the axis values and bounds for use in calls to cmor api
    """
    arg_values = (axis.getValue(), axis.getBounds())
    return dict(list(zip(keys, arg_values)))


class AxisMakerFactory(object):
    """
    Different types of axes have different calls to the cmor api depending on what
    arguments they need to pass into cmor.axis or whether they have zfactors or not.
    The calls to the cmor api to define the axes for a variable are performed by
    a set of classes called AxisMaker(s).

    The AxisMakerFactory determines which AxisMaker to use depending on the
    characteristics of the axis, and the axes expected in the MIP table.

    Note: I do not think this class is as clean as it should be.  I have
    toyed with different places to put this logic, and in the presense of uncertainty
    have (for now) settled on leaving it in a class on its own with the interface
    it has.
    """
    # I like this class less and less

    # hard coded - could be improved?
    UNIT_2_AXIS = {'hPa': 'plevs', 'm': 'depth_coord'}
    GRID_TABLE = '%s_grids'
    VERTICAL = mip_convert.common.VERTICAL
    LATLON = mip_convert.common.LATLON
    HORIZONTAL = mip_convert.common.HORIZONTAL

    def __init__(self, table, mip_variable, cmor):
        """
        @param table: the table object for this factory to
        @param mip_variable: the name of the mip variable to output
        @param cmor: an object with a CMOR API
        """
        self._table = table
        self._mip_variable = mip_variable
        self._cmor = cmor
        self._table_name = table.table_name

    def grid_table(self):
        name = self.GRID_TABLE % self._table.table_prefix
        if self._table_name.endswith('.json'):
            name = name + '.json'
        return name

    def _entry_name(self, axis_dir, variable):
        """
        return the axis_entry in the MIP table for this direction, based on variable
        """
        if variable.is_rotated and axis_dir in self.LATLON:
            result = 'grid_' + self._entry(axis_dir)
        elif variable.is_tripolar and axis_dir in self.LATLON:
            if axis_dir == 'X':
                result = 'i_index'
            if axis_dir == 'Y':
                result = 'j_index'
        elif axis_dir == self.VERTICAL and self._generic_level(self._entry(axis_dir)):
            result = self._resolve_vertical_axis_name(axis_dir, variable)
        else:
            result = self._entry(axis_dir)
        return result

    def _resolve_vertical_axis_name(self, axis_dir, variable):
        """
        return the best guess as the name of the vertical level in the MIP table

        This uses the  axis.is_hybrid_height or the units to determine what
        the best mip axis name is.  The mip axis names are hard coded.
        There is room for improvement, if needed, in the future.
        """
        axis = variable.getAxis(axis_dir)
        if axis.units in self.UNIT_2_AXIS:
            result = self.UNIT_2_AXIS[axis.units]
        else:
            raise CmorOutputError("can not determine generic level type for current variable")
        return result

    def _entry(self, axis_dir):
        """
        return the MIP table axis_entry in the direction axis_dir
        """
        result = ''
        for dim_name in self._mip_variable.dimensions:
            if dim_name not in self._table.axes:  # e.g. 'alevel'
                continue
            axis = self._table.axes[dim_name]
            if axis.axis == axis_dir:
                result = axis.entry
                break
        return result

    def is_horizontal(self, axis_dir):
        return axis_dir in self.HORIZONTAL

    def has_axis(self, axis_dir):
        return axis_dir in self.axis_dirs()

    def has_time(self):
        return self.has_axis(TIME_TYPE)

    def z_axis(self):
        # there are other algorithms, but this reflect similarity to horizonal axis extraction
        return [axis for axis in self.axis_dirs() if axis == self.VERTICAL]

    def horizontal_axes(self):
        return [axis for axis in self.axis_dirs() if self.is_horizontal(axis)]

    def non_spatial_axes(self):
        result = []
        for axis in self.axis_dirs():
            if axis not in self.horizontal_axes() and axis not in self.z_axis():
                result.append(axis)
        return result

    # TODO: this may live elsewhere
    def getAxisMaker(self, axis_dir, variable):
        """
        return an AxisMaker for the axis from the variable in the direction axis_dir
        @param axis_dir: the axis direction: one of "X", "Y", "Z", "T"
        @param variable: variable to return the AxisMaker for.

        The details of the axes depend on the variable - for instance whether it
        is on hybrid heights.
        """
        axis = variable.getAxis(axis_dir)
        if axis.axis == TIME_TYPE:
            result = TimeAxisMaker(self._table_name, self._entry(axis_dir), axis, self._cmor)
        elif axis.axis == SITE_TYPE:
            result = SiteAxisMaker(self._table_name, self._entry(axis_dir), axis, self._cmor)
        elif axis.is_hybrid_height:
            result = HybridHeightAxisMaker(self._table_name, axis, self._cmor)
        elif axis.axis == REFTIME_TYPE:
            result = SimpleAxisMaker(self._table_name, "reftime1", axis, self._cmor)
        else:
            result = SimpleAxisMaker(self._table_name, self._entry_name(axis_dir, variable), axis, self._cmor)
        return result

    def _generic_level(self, dim_name):
        """
        return True if dim_name is a generic_level
        """
        # if dimension is passed as a blank string this has already been deemed a generic level
        # TODO: refactor this and the _entry method used by _entry_name
        return dim_name in self._table.generic_levels or dim_name == ''

    def axis_dirs(self):
        """
        return the axis directions known about by this axis maker factory
        """
        result = list()
        for dim_name in self._mip_variable.dimensions:
            if dim_name == 'leadtime':
                # leadtime is ignored as this will be handled by the CMOR itself
                continue
            elif self._generic_level(dim_name):
                dim_dir = self.VERTICAL
            elif dim_name == 'reftime1':
                # use the dummy time axis instead of regular one to avoid ambiguity
                dim_dir = 'T-reftime'
            else:
                axis = self._table.axes[dim_name]
                dim_dir = axis.axis
            result.append(dim_dir)
        return result

    def reset_table(self):
        self._cmor.load_table(self._table_name)

    def use_grid_table(self):
        self._cmor.load_table(self.grid_table())

    def grid(self, axis_ids, domain):
        return self._cmor.grid(axis_ids,
                               domain.geo_latitudes(),
                               domain.geo_longitudes(),
                               domain.geo_latitude_vertices(),
                               domain.geo_longitude_vertices())

    def set_grid_mapping(self, *args):
        return self._cmor.set_grid_mapping(*args)


class AbstractAxisMaker(object):
    """
    Abstract base class, subclasses of which provides capabiltiy to retrieve the
    CMOR axis ID for an axis.  The axis id made by an AxisMaker will have made all
    the relavant calls to cmor - including the definition of any zfactors.  Subclasses
    of AxisMaker are responsible for providing a method _keydict (see documentation).  Where
    they need to set zfactors they should override the default implementations of _zfactors and
    set_horizontal.

    This class also provides caching of cmor axis ids to prevent unecessary
    calls to cmor axis.  Output variables that share the same axes (because they
    are on the same grid) should share the same axis_ids to prevent cmor having to
    manage many axis_ids.  This is achieved by storing the axis_ids after they
    have been created in a class global dictionary.
    """

    axis_cache = dict()

    def __init__(self, table, entry, axis, cmor):
        """
        @param table: table id for this axis
        @param entry: the MIP table axis_entry for this axis
        @param axis: the axis object
        @param cmor: cmor API object
        """
        self.axis = axis
        self.entry = entry
        self.cmor = cmor
        self.table = table

    def cmorId(self):
        """
        return the axis id generated by a call to cmor.axis
        """
        # FIXME: would be better to have the axes defined there own __hash__ method
        # don't use dict.setdefault as don't want _newId() to always be called
        if self._cache_key() not in AbstractAxisMaker.axis_cache:
            AbstractAxisMaker.axis_cache[self._cache_key()] = self._newId()
        return AbstractAxisMaker.axis_cache[self._cache_key()]

    def _newId(self):
        """
        return a new cmor axis id, and define any zfactors
        """
        axis_id = self.cmor.axis(self.entry, **self._keywords())
        self._zfactors(axis_id)
        return axis_id

    def _zfactors(self, axis_id):
        """
        define any zfactors for this axis
        """
        pass

    def _keywords(self):
        """
        return the full dictionary of the keyword arguments for the call to cmor.axis
        """
        axis_kw = self._keydict()
        axis_kw['units'] = self.axis.units
        return axis_kw

    def _keydict(self):
        """
        return a partial dictionary of the keyword arguments for the call to cmor.axis

        the dictionary should not contain units (which is why it is called partial), as this is added later
        """
        raise NotImplementedError('abstract method')

    def set_horizontal(self, horizontal_ids):
        """
        use this to set the horizonal axis_ids that may be needed to define z factors
        (e.g. for orography z factor used in HybridHeight)
        """
        pass

    def _cache_key(self):
        """
        return the key value for use in the dictionary cache
        """
        return self.table + self.entry + repr(self._keywords())


class SimpleAxisMaker(AbstractAxisMaker):
    """
    A simple horizontal or none-hybrid height axis maker
    """

    def _keydict(self):
        """
        the keywords for CMOR.axis for this type of axis will include
        coord_vals and cell_bounds.
        """
        axis_kw = axisKeyWords(self.axis, ('coord_vals', 'cell_bounds'))
        return axis_kw


class HybridHeightAxisMaker(SimpleAxisMaker):
    """
    An axis maker for hybrid height coordinates.
    """

    # hard coded for CMIP5 - and duplicates information
    OROG = 'orog'

    def __init__(self, table, axis, cmor):
        """
        @param table: the MIP table id
        @param axis: the axis for which the axis ids are needed
        @param cmor: an object with a cmor like interface.
        """
        super(HybridHeightAxisMaker, self).__init__(table, axis.name, axis, cmor)
        self._axis_name = axis.name
        self.horiz_ids = None

    @property
    def _bfactor(self):
        bfactor = 'b'
        if 'half' in self._axis_name:
            bfactor = 'b_half'
        return bfactor

    def _cache_key(self):
        """
        return a key that identifies this axis for cmor.

        in this case have to append the superclass key with the horizontal
        axis ids of the orography so can destinguish between hybrid height axes
        that are for variables on different horizontal grids.
        """
        return super(HybridHeightAxisMaker, self)._cache_key() + (' orog_axes:' + repr(self.horiz_ids))

    def set_horizontal(self, horizontal_ids):
        self.horiz_ids = horizontal_ids

    def _zfactors(self, axis_id):
        self.cmor.zfactor(axis_id,
                          self._bfactor,
                          axis_ids=[axis_id],
                          zfactor_values=self.axis.getBvalues(),
                          zfactor_bounds=self.axis.getBbounds())

        self.cmor.zfactor(axis_id,
                          self.OROG,
                          axis_ids=self.horiz_ids,
                          units=self.axis.getOrographyUnits(),
                          zfactor_values=self.axis.getOrography())


class TimeAxisMaker(AbstractAxisMaker):
    """
    An axis maker for time.  Time needs a special axis maker as it is the unlimited
    dimension and so the axis values are not known at axis definition time.
    """

    def _keydict(self):
        return {}


class SiteAxisMaker(SimpleAxisMaker):
    """
    An axis maker for arbitrarily-located sites (aka stations in CF-speak).

    To output site data in CF-compliant fashion it is necessary to obtain the (lat,long) coords of
    the sites and write these arrays to the netcdf file as auxiliary coord variables. This is done
    here via the call to cmor.grid()
    """

    def _keydict(self):
        return dict(coord_vals=self.axis.getValue())

    def _newId(self):
        """
        Return a cmor.axis object representing a site axis. The cmor.grid object associated with
        this axis can be obtained by calling the cmorGridId() method.
        """
        axis_id = self.cmor.axis(self.entry, **self._keywords())
        return self._grid([axis_id])

    def _grid(self, axis_ids):
        grid_id = self.cmor.grid(axis_ids, self.axis.lats, self.axis.lons)
        return grid_id
