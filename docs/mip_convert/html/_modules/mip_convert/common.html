
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>mip_convert.common &#8212; MIP Convert 2.3.3.dev0+main.2f65f7c-M documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/nature.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <link rel="author" title="About these documents" href="../../about.html" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">MIP Convert 2.3.3.dev0+main.2f65f7c-M documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">mip_convert.common</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for mip_convert.common</h1><div class="highlight"><pre>
<span></span><span class="c1"># (C) British Crown Copyright 2009-2022, Met Office.</span>
<span class="c1"># Please see LICENSE.rst for license details.</span>
<span class="c1"># pylint: disable = eval-used</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">cftime</span> <span class="kn">import</span> <span class="n">datetime</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">netcdftime</span> <span class="kn">import</span> <span class="n">datetime</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">itemgetter</span>
<span class="kn">import</span> <span class="nn">regex</span> <span class="k">as</span> <span class="nn">re</span>
<span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="kn">import</span> <span class="n">distance</span>

<span class="kn">import</span> <span class="nn">iris</span>
<span class="kn">from</span> <span class="nn">iris.fileformats.pp</span> <span class="kn">import</span> <span class="n">STASH</span>

<span class="kn">from</span> <span class="nn">cdds.common</span> <span class="kn">import</span> <span class="n">DATE_TIME_REGEX</span>
<span class="kn">from</span> <span class="nn">cdds.common.constants</span> <span class="kn">import</span> <span class="n">ANCIL_VARIABLES</span>
<span class="kn">from</span> <span class="nn">cdds.common.plugins.plugins</span> <span class="kn">import</span> <span class="n">PluginStore</span>
<span class="kn">from</span> <span class="nn">cdds.common.plugins.grid</span> <span class="kn">import</span> <span class="n">GridType</span>

<span class="n">TIME_TYPE</span> <span class="o">=</span> <span class="s1">&#39;T&#39;</span>
<span class="n">REFTIME_TYPE</span> <span class="o">=</span> <span class="s1">&#39;T-reftime&#39;</span>
<span class="n">LANDTYPE_AXIS</span> <span class="o">=</span> <span class="s1">&#39;vegtype&#39;</span>
<span class="n">TAU_AXIS</span> <span class="o">=</span> <span class="s1">&#39;tau&#39;</span>
<span class="n">SITE_TYPE</span> <span class="o">=</span> <span class="s1">&#39;site&#39;</span>
<span class="n">VERTICAL</span> <span class="o">=</span> <span class="s1">&#39;Z&#39;</span>
<span class="n">LATLON</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">]</span>
<span class="n">HORIZONTAL</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">LATLON</span> <span class="o">+</span> <span class="p">[</span><span class="n">SITE_TYPE</span><span class="p">])</span>
<span class="n">FIELD_ATTRIBUTE_NAMES_WITH_TUPLE_VALUE</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;lbrsvd&#39;</span><span class="p">,</span> <span class="s1">&#39;lbuser&#39;</span><span class="p">,</span> <span class="s1">&#39;brsvd&#39;</span><span class="p">)</span>
<span class="n">SUPPORTED_PP_CONSTRAINTS</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;blev&#39;</span><span class="p">,</span> <span class="s1">&#39;lblev&#39;</span><span class="p">,</span> <span class="s1">&#39;lbplev&#39;</span><span class="p">,</span> <span class="s1">&#39;lbproc&#39;</span><span class="p">,</span> <span class="s1">&#39;lbtim&#39;</span><span class="p">,</span> <span class="s1">&#39;stash&#39;</span><span class="p">]</span>
<span class="n">SUPPORTED_NETCDF_CONSTRAINTS</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;variable_name&#39;</span><span class="p">,</span> <span class="s1">&#39;cell_methods&#39;</span><span class="p">,</span> <span class="s1">&#39;depth&#39;</span><span class="p">]</span>
<span class="n">SUPPORTED_CONSTRAINTS</span> <span class="o">=</span> <span class="n">SUPPORTED_PP_CONSTRAINTS</span> <span class="o">+</span> <span class="n">SUPPORTED_NETCDF_CONSTRAINTS</span>
<span class="n">PP_TO_CUBE_CONSTRAINTS</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;stash&#39;</span><span class="p">:</span> <span class="s1">&#39;lbuser4&#39;</span><span class="p">,</span> <span class="s1">&#39;lbplev&#39;</span><span class="p">:</span> <span class="s1">&#39;lbuser5&#39;</span><span class="p">}</span>
<span class="n">DEFAULT_FILL_VALUE</span> <span class="o">=</span> <span class="mf">1e+20</span>
<span class="n">LBPROC_DEFAULT</span> <span class="o">=</span> <span class="mi">128</span>
<span class="n">LBTIM_DEFAULT_MEAN</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">LBTIM_DEFAULT_POINT</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>


<span class="c1"># The rest of the code uses both numpys and lists to represent</span>
<span class="c1"># longitudes (mistake on my part - using a numpys through out would be</span>
<span class="c1"># better, but I didn&#39;t have the time to fix/refactor this when working</span>
<span class="c1"># on this code). This means the code for dealing with longitude ranges</span>
<span class="c1"># should deal with both and not change their type.</span>
<span class="c1"># To keep too many &#39;if&#39;s out of the main control flow the wrapper</span>
<span class="c1"># classes (_ListWrapper and _NumpyWrapper) are introduced - they</span>
<span class="c1"># present numpys and lists as the same interface for the key logic.</span>
<span class="c1"># There may be other ways to do this - it was the best I could think of</span>
<span class="c1"># today.</span>


<span class="k">class</span> <span class="nc">_ListWrapper</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrapper for a list class to give it an interface a little like</span>
<span class="sd">    a numpy array.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">values</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_ListWrapper</span><span class="p">([</span><span class="n">x</span> <span class="o">+</span> <span class="n">other</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">max</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">min</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_NumpyWrapper</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrapper for a numpy class to give it an interface that can be</span>
<span class="sd">    used in the Longitudes calculation.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">values</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_NumpyWrapper</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">+</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">max</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">min</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">Longitudes</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class to represent a sequence of longitudes (in degrees)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_PERIOD</span> <span class="o">=</span> <span class="mi">360</span>
    <span class="n">_MAX_LONGITUDE</span> <span class="o">=</span> <span class="n">_PERIOD</span>
    <span class="n">_MIN_LONGITUDE</span> <span class="o">=</span> <span class="o">-</span><span class="mi">180</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param values: list or numpy of longitude values</span>
<span class="sd">                       assumed to be in degrees (no checking)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># make sure the data has the same interface to make following</span>
        <span class="c1"># logic simpler</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_values</span> <span class="o">=</span> <span class="n">_ListWrapper</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_values</span> <span class="o">=</span> <span class="n">_NumpyWrapper</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">within_range</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the longitudes in a range between -180 and 360 degrees</span>
<span class="sd">        the type returned is consistent with the type passed into the</span>
<span class="sd">        constructor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_less_than_max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">)</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_more_than_min</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">values</span><span class="o">.</span><span class="n">data</span>

    <span class="k">def</span> <span class="nf">_make_less_than_max</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAX_LONGITUDE</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_PERIOD</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_offset</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">offset</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_make_more_than_min</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="c1"># asymmetrical with _make_less_than_max</span>
        <span class="c1"># _make_less_than_max has already bought within -360-360</span>
        <span class="k">if</span> <span class="n">values</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MIN_LONGITUDE</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_offset</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_PERIOD</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">values</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_apply_offset</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">offset</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">values</span> <span class="o">+</span> <span class="n">offset</span>


<span class="k">class</span> <span class="nc">ObjectWithLogger</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class providing an object with a logger.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__module__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>


<span class="k">class</span> <span class="nc">VersionString</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Lightweight class to represent version strings, allows comparison</span>
<span class="sd">    of a UM version string with a float.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># this is a barebones implementation enough to enable progress</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param value: a string of the form &#39;x&#39;, or &#39;x.y&#39;, or &#39;x.y.z&#39;</span>
<span class="sd">                      in the latter case the micro version number z is</span>
<span class="sd">                      thrown away</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">parts</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">value</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_version</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_version</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_version</span> <span class="o">+</span> <span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mf">10.</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return conventional values for cmp. Compares self to a float</span>
<span class="sd">        other.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_version</span> <span class="o">&lt;</span> <span class="n">other</span>

    <span class="k">def</span> <span class="fm">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return conventional values for cmp. Compares self to a float</span>
<span class="sd">        other.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_version</span> <span class="o">&gt;</span> <span class="n">other</span>

    <span class="k">def</span> <span class="fm">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return conventional values for cmp. Compares self to a float</span>
<span class="sd">        other.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_version</span> <span class="o">&lt;=</span> <span class="n">other</span>

    <span class="k">def</span> <span class="fm">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return conventional values for cmp. Compares self to a float</span>
<span class="sd">        other.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_version</span> <span class="o">&gt;=</span> <span class="n">other</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return conventional values for cmp. Compares self to a float</span>
<span class="sd">        other.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_version</span> <span class="o">==</span> <span class="n">other</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return conventional values for cmp. Compares self to a float</span>
<span class="sd">        other.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_version</span> <span class="o">!=</span> <span class="n">other</span>


<span class="k">class</span> <span class="nc">RelativePathError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Exception if a path does not exist or is not expected type.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">RelativePathChecker</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Provides file names relative to a base path.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">NO_PATH</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> path &quot;</span><span class="si">%s</span><span class="s1">&quot; does not exist&#39;</span>
    <span class="n">NOT_DIR</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> path &quot;</span><span class="si">%s</span><span class="s1">&quot; not a directory&#39;</span>
    <span class="n">NOT_FILE</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> path &quot;</span><span class="si">%s</span><span class="s1">&quot; not a file&#39;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">description</span><span class="p">,</span> <span class="n">os_path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param base: - the base path to provide</span>
<span class="sd">        :param description: - descriptive text for the files in this</span>
<span class="sd">                              directory, used in error messages</span>
<span class="sd">        :param os_path: - object with the same interface as the os_path</span>
<span class="sd">                          module</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">os_path</span> <span class="o">=</span> <span class="n">os_path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span> <span class="o">=</span> <span class="n">base</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">description</span> <span class="o">=</span> <span class="n">description</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_checkDir</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_errorExist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ypath</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Throw an exception if the path ypath does not exist.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">os_path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">ypath</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">RelativePathError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_checkDir</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Throw an exception if the base directory does not exist or is</span>
<span class="sd">        not a directory.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_errorExist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">NO_PATH</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">description</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">os_path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">RelativePathError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NOT_DIR</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">description</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">fullFileName</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">relative</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the full file name for the file &quot;relative&quot;.</span>

<span class="sd">        Raises and exception if the file does not exist or is not a</span>
<span class="sd">        file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">full_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">os_path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">relative</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_errorExist</span><span class="p">(</span><span class="n">full_path</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">NO_PATH</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">description</span><span class="p">,</span> <span class="n">full_path</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">os_path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">full_path</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">RelativePathError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NOT_FILE</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">description</span><span class="p">,</span> <span class="n">full_path</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">full_path</span>


<div class="viewcode-block" id="check_extension"><a class="viewcode-back" href="../../mip_convert/common.html#mip_convert.common.check_extension">[docs]</a><span class="k">def</span> <span class="nf">check_extension</span><span class="p">(</span><span class="n">filenames</span><span class="p">,</span> <span class="n">extension</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return whether the files provided to the ``filenames`` parameter</span>
<span class="sd">    all have the same extension provided to the ``extension``</span>
<span class="sd">    parameter.</span>

<span class="sd">    :param filenames: the names of the files to be checked</span>
<span class="sd">    :type filenames: list of strings</span>
<span class="sd">    :param extension: the expected extension of the files</span>
<span class="sd">    :type extension: string</span>
<span class="sd">    :return: whether the files have the same extension</span>
<span class="sd">    :rtype: boolean</span>

<span class="sd">    :Examples:</span>

<span class="sd">    &gt;&gt;&gt; check_extension([&#39;file1.nc&#39;, &#39;file2.nc&#39;, &#39;file3.nc&#39;], &#39;.nc&#39;)</span>
<span class="sd">    True</span>

<span class="sd">    &gt;&gt;&gt; check_extension([&#39;file1.pp&#39;, &#39;file2.pp&#39;, &#39;file3.pp&#39;], &#39;.nc&#39;)</span>
<span class="sd">    False</span>

<span class="sd">    &gt;&gt;&gt; check_extension([&#39;file1.nc&#39;, &#39;file2.pp&#39;, &#39;file3&#39;], &#39;.nc&#39;)</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">test_extension</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span> <span class="k">if</span> <span class="n">filename</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="n">extension</span><span class="p">)</span> <span class="k">else</span> <span class="kc">False</span> <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">filenames</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">test_extension</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="kc">True</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">test_extension</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="check_values_equal"><a class="viewcode-back" href="../../mip_convert/common.html#mip_convert.common.check_values_equal">[docs]</a><span class="k">def</span> <span class="nf">check_values_equal</span><span class="p">(</span><span class="n">value1</span><span class="p">,</span> <span class="n">value2</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.001</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return whether ``value1`` and ``value2`` are equal.</span>

<span class="sd">    The ``tolerance`` is used to check whether two floats are equal.</span>

<span class="sd">    :param value1: the first value to check</span>
<span class="sd">    :type value1: string or numeric</span>
<span class="sd">    :param value2: the second value to check</span>
<span class="sd">    :type value2: string or numeric</span>
<span class="sd">    :param tolerance: the tolerance used when checking whether two</span>
<span class="sd">        floats are equal</span>
<span class="sd">    :type tolerance: float</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value1</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value2</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">)):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">value1</span> <span class="o">-</span> <span class="n">value2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tolerance</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">value1</span> <span class="o">==</span> <span class="n">value2</span>
    <span class="k">return</span> <span class="n">result</span></div>


<span class="k">def</span> <span class="nf">is_time_constant</span><span class="p">(</span><span class="n">cube</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return True if the cube does not have a time axis so is time constant.</span>

<span class="sd">    :param cube: the cube to check</span>
<span class="sd">    :type coord: :class:`iris.cube.Cube`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">cube</span><span class="o">.</span><span class="n">coords</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span>


<span class="k">def</span> <span class="nf">apply_time_constraint</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="n">time_constraint_function</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the cube after applying the time constraint.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cubes: :class:`iris.cube.Cube`</span>
<span class="sd">        The cube to apply the time constraint to.</span>
<span class="sd">    time_constraint_function: callable</span>
<span class="sd">        A function which accepts a :class:`iris.coords.Cell` instance as</span>
<span class="sd">        its first and only argument returning True or False if the value</span>
<span class="sd">        of the ``Cell`` is desired.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    : :class:`iris.cube.Cube`</span>
<span class="sd">        The cube after applying the time constraint.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Don&#39;t apply time constraints to cubes that are time constant.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_time_constant</span><span class="p">(</span><span class="n">cube</span><span class="p">):</span>
        <span class="n">time_constraint</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">Constraint</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="n">time_constraint_function</span><span class="p">)</span>
        <span class="n">time_dim_coord</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">coords</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="n">dim_coords</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">cube</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">time_constraint</span><span class="p">)</span>

        <span class="c1"># The time coordinate is sometimes set as scalar after applying a</span>
        <span class="c1"># time constraint; put it back.</span>
        <span class="k">if</span> <span class="n">cube</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">time_dim_coord</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">cube</span><span class="o">.</span><span class="n">coords</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="n">dim_coords</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">time_dim_coord</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;More than 1 time coordinate available&#39;</span><span class="p">)</span>
                <span class="n">cube</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">new_axis</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="n">time_dim_coord</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">cube</span>


<div class="viewcode-block" id="separate_date"><a class="viewcode-back" href="../../mip_convert/common.html#mip_convert.common.separate_date">[docs]</a><span class="k">def</span> <span class="nf">separate_date</span><span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="n">date_regex</span><span class="o">=</span><span class="n">DATE_TIME_REGEX</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Separate the date provided to the ``date`` parameter into</span>
<span class="sd">    components i.e., year, month, day, hours, minutes, seconds based on</span>
<span class="sd">    the regular expression provided to the ``date_regex`` parameter</span>

<span class="sd">    :param date: the date to be separated</span>
<span class="sd">    :type date: string</span>
<span class="sd">    :param date_regex: the regular expression describing the format of</span>
<span class="sd">                       the date</span>
<span class="sd">    :type date_regex: string</span>
<span class="sd">    :return: the components of the date</span>
<span class="sd">    :rtype: dictionary</span>

<span class="sd">    :Examples:</span>

<span class="sd">    &gt;&gt;&gt; date = separate_date(</span>
<span class="sd">    ...     &#39;1970-02-01&#39;,</span>
<span class="sd">    ...     &#39;(?P&lt;year&gt;\\d{4})-(?P&lt;month&gt;\\d{2})-(?P&lt;day&gt;\\d{2})&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(type(date))</span>
<span class="sd">    &lt;class &#39;dict&#39;&gt;</span>
<span class="sd">    &gt;&gt;&gt; print(date[&#39;year&#39;], date[&#39;month&#39;], date[&#39;day&#39;])</span>
<span class="sd">    1970 2 1</span>

<span class="sd">    &gt;&gt;&gt; date = separate_date(</span>
<span class="sd">    ...     &#39;1970-01-01 00:00:00&#39;,</span>
<span class="sd">    ...     &#39;(?P&lt;year&gt;\\d{4})-(?P&lt;month&gt;\\d{2})-(?P&lt;day&gt;\\d{2})\\s&#39;</span>
<span class="sd">    ...     &#39;(?P&lt;hour&gt;\\d{2}):(?P&lt;minute&gt;\\d{2}):(?P&lt;second&gt;\\d{2})&#39;)</span>
<span class="sd">    &gt;&gt;&gt; for component in sorted(date.items()):</span>
<span class="sd">    ...     print(component)</span>
<span class="sd">    (&#39;day&#39;, 1)</span>
<span class="sd">    (&#39;hour&#39;, 0)</span>
<span class="sd">    (&#39;minute&#39;, 0)</span>
<span class="sd">    (&#39;month&#39;, 1)</span>
<span class="sd">    (&#39;second&#39;, 0)</span>
<span class="sd">    (&#39;year&#39;, 1970)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">matched</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;^</span><span class="si">{}</span><span class="s1">$&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">date_regex</span><span class="p">))</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">date</span><span class="p">)</span><span class="o">.</span><span class="n">groupdict</span><span class="p">()</span>
    <span class="k">return</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">matched</span><span class="o">.</span><span class="n">items</span><span class="p">())}</span></div>


<div class="viewcode-block" id="format_date"><a class="viewcode-back" href="../../mip_convert/common.html#mip_convert.common.format_date">[docs]</a><span class="k">def</span> <span class="nf">format_date</span><span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="n">date_regex</span><span class="o">=</span><span class="n">DATE_TIME_REGEX</span><span class="p">,</span>
                <span class="n">output_format</span><span class="o">=</span><span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1"> %H:%M:%S&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert the format of the date provided to the ``date`` parameter</span>
<span class="sd">    from the format provided to the ``date_regex`` parameter to the</span>
<span class="sd">    format provided to the ``output_format`` parameter.</span>

<span class="sd">    :param date: the date to be formatted</span>
<span class="sd">    :type date: string</span>
<span class="sd">    :param date_regex: the regular expression describing the format</span>
<span class="sd">                        of the date</span>
<span class="sd">    :type date_regex: string</span>
<span class="sd">    :param output_format: the output format</span>
<span class="sd">    :type output_format: string</span>
<span class="sd">    :return: the formatted date</span>
<span class="sd">    :rtype: string</span>

<span class="sd">    :Examples:</span>

<span class="sd">    &gt;&gt;&gt; print(format_date(</span>
<span class="sd">    ...     &#39;19700101000000&#39;,</span>
<span class="sd">    ...     &#39;(?P&lt;year&gt;\\d{4})(?P&lt;month&gt;\\d{2})(?P&lt;day&gt;\\d{2})&#39;</span>
<span class="sd">    ...     &#39;(?P&lt;hour&gt;\\d{2})(?P&lt;minute&gt;\\d{2})(?P&lt;second&gt;\\d{2})&#39;,</span>
<span class="sd">    ...     &#39;%Y-%m-%d-%H-%M-%S&#39;))</span>
<span class="sd">    1970-01-01-00-00-00</span>

<span class="sd">    &gt;&gt;&gt; print(format_date(</span>
<span class="sd">    ...     &#39;1970-01-01-00-00-00&#39;, output_format=&#39;%Y%m%d&#39;))</span>
<span class="sd">    19700101</span>

<span class="sd">    &gt;&gt;&gt; print(format_date(&#39;1970-01-01-00-00-00&#39;))</span>
<span class="sd">    1970-01-01 00:00:00</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">date_components</span> <span class="o">=</span> <span class="n">separate_date</span><span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="n">date_regex</span><span class="p">)</span>
    <span class="n">date_time</span> <span class="o">=</span> <span class="n">datetime</span><span class="p">(</span>
        <span class="n">date_components</span><span class="p">[</span><span class="s1">&#39;year&#39;</span><span class="p">],</span> <span class="n">date_components</span><span class="p">[</span><span class="s1">&#39;month&#39;</span><span class="p">],</span>
        <span class="n">date_components</span><span class="p">[</span><span class="s1">&#39;day&#39;</span><span class="p">],</span> <span class="n">date_components</span><span class="p">[</span><span class="s1">&#39;hour&#39;</span><span class="p">],</span>
        <span class="n">date_components</span><span class="p">[</span><span class="s1">&#39;minute&#39;</span><span class="p">],</span> <span class="n">date_components</span><span class="p">[</span><span class="s1">&#39;second&#39;</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">date_time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="n">output_format</span><span class="p">)</span></div>


<div class="viewcode-block" id="nearest_coordinates"><a class="viewcode-back" href="../../mip_convert/common.html#mip_convert.common.nearest_coordinates">[docs]</a><span class="k">def</span> <span class="nf">nearest_coordinates</span><span class="p">(</span><span class="n">coordinates1</span><span class="p">,</span> <span class="n">coordinates2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the coordinates in ``coordinates2`` that are nearest to the</span>
<span class="sd">    coordinates in ``coordinates1`` in the order of ``coordinates1``.</span>

<span class="sd">    This function uses Euclidean geometry.</span>

<span class="sd">    :param coordinates1: the coordinates to compare to ``coordinates2``</span>
<span class="sd">    :type coordinates1: list of (longitude, latitude) tuples [degrees]</span>
<span class="sd">    :param coordinates2: the coordinates to compare to ``coordinates1``</span>
<span class="sd">    :type coordinates2: list of (longitude, latitude) tuples [degrees]</span>
<span class="sd">    :return: the coordinates in ``coordinates2`` that are nearest to</span>
<span class="sd">        the coordinates in ``coordinates1``</span>
<span class="sd">    :rtype: list of (longitude, latitude) tuples [degrees]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
    <span class="c1"># Using Euclidean geometry instead of Spherical geometry is good</span>
    <span class="c1"># enough in this case.</span>
    <span class="n">distance_matrix</span> <span class="o">=</span> <span class="n">distance</span><span class="o">.</span><span class="n">cdist</span><span class="p">(</span><span class="n">coordinates1</span><span class="p">,</span> <span class="n">coordinates2</span><span class="p">,</span> <span class="s1">&#39;euclidean&#39;</span><span class="p">)</span>
    <span class="c1"># Use np.argmin to determine the indicies corresponding to the</span>
    <span class="c1"># minimum distances in the &#39;distance_matrix&#39;; use axis=1 to</span>
    <span class="c1"># return a list with the same length as &#39;coordinates1&#39;.</span>
    <span class="n">minimum_distance_indicies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">distance_matrix</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">minimum_distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">distance_matrix</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">coordinates</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">maximum_distance_for_nearest_coordinate</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">for</span> <span class="n">count</span><span class="p">,</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">minimum_distance_indicies</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">minimum_distance</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">maximum_distance_for_nearest_coordinate</span><span class="p">):</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s1">&#39;Coordinate </span><span class="si">{coordinate2}</span><span class="s1"> more than </span><span class="si">{distance}</span><span class="s1"> degree from coordinate </span><span class="si">{coordinate1}</span><span class="s1">&#39;</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">message</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">coordinate2</span><span class="o">=</span><span class="n">coordinates2</span><span class="p">[</span><span class="n">index</span><span class="p">],</span>
                                          <span class="n">distance</span><span class="o">=</span><span class="n">maximum_distance_for_nearest_coordinate</span><span class="p">,</span>
                                          <span class="n">coordinate1</span><span class="o">=</span><span class="n">coordinates1</span><span class="p">[</span><span class="n">count</span><span class="p">]))</span>
        <span class="n">coordinates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coordinates2</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">coordinates</span></div>


<div class="viewcode-block" id="replace_coord_points_bounds"><a class="viewcode-back" href="../../mip_convert/common.html#mip_convert.common.replace_coord_points_bounds">[docs]</a><span class="k">def</span> <span class="nf">replace_coord_points_bounds</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">dim_coord</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the coordinate provided to the ``coord`` parameter with</span>
<span class="sd">    the points and bounds replaced with the values provided to the</span>
<span class="sd">    ``points`` and ``bounds`` parameters, respectively.</span>

<span class="sd">    This function can be used when the replacement points have a</span>
<span class="sd">    different shape to the points that already exist on the coordinate;</span>
<span class="sd">    since it is not possible to simply use ``coord.points = points`` in</span>
<span class="sd">    this case (a ValueError &quot;New points shape must match existing</span>
<span class="sd">    points shape&quot; is raised), a new :class:`iris.coords.DimCoord` or</span>
<span class="sd">    :class:`iris.coords.AuxCoord` object is returned with the requested</span>
<span class="sd">    points and bounds.</span>

<span class="sd">    :param coord: the coordinate to update</span>
<span class="sd">    :type coord: :class:`iris.coords.DimCoord` or</span>
<span class="sd">        :class:`iris.coords.AuxCoord`</span>
<span class="sd">    :param points: the new array of values for each cell</span>
<span class="sd">    :type points: Numpy array</span>
<span class="sd">    :param bounds: the new array of values describing the bounds of</span>
<span class="sd">        each cell</span>
<span class="sd">    :return: the updated coordinate</span>
<span class="sd">    :rtype: :class:`iris.coords.DimCoord` or</span>
<span class="sd">        :class:`iris.coords.AuxCoord`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">dim_coord</span><span class="p">:</span>
        <span class="n">updated_coord</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">DimCoord</span><span class="p">(</span>
            <span class="n">points</span><span class="p">,</span> <span class="n">standard_name</span><span class="o">=</span><span class="n">coord</span><span class="o">.</span><span class="n">standard_name</span><span class="p">,</span>
            <span class="n">long_name</span><span class="o">=</span><span class="n">coord</span><span class="o">.</span><span class="n">long_name</span><span class="p">,</span> <span class="n">var_name</span><span class="o">=</span><span class="n">coord</span><span class="o">.</span><span class="n">var_name</span><span class="p">,</span>
            <span class="n">units</span><span class="o">=</span><span class="n">coord</span><span class="o">.</span><span class="n">units</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span> <span class="n">attributes</span><span class="o">=</span><span class="n">coord</span><span class="o">.</span><span class="n">attributes</span><span class="p">,</span>
            <span class="n">coord_system</span><span class="o">=</span><span class="n">coord</span><span class="o">.</span><span class="n">coord_system</span><span class="p">,</span> <span class="n">circular</span><span class="o">=</span><span class="n">coord</span><span class="o">.</span><span class="n">circular</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">updated_coord</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">AuxCoord</span><span class="p">(</span>
            <span class="n">points</span><span class="p">,</span> <span class="n">standard_name</span><span class="o">=</span><span class="n">coord</span><span class="o">.</span><span class="n">standard_name</span><span class="p">,</span>
            <span class="n">long_name</span><span class="o">=</span><span class="n">coord</span><span class="o">.</span><span class="n">long_name</span><span class="p">,</span> <span class="n">var_name</span><span class="o">=</span><span class="n">coord</span><span class="o">.</span><span class="n">var_name</span><span class="p">,</span>
            <span class="n">units</span><span class="o">=</span><span class="n">coord</span><span class="o">.</span><span class="n">units</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span>
            <span class="n">attributes</span><span class="o">=</span><span class="n">coord</span><span class="o">.</span><span class="n">attributes</span><span class="p">,</span> <span class="n">coord_system</span><span class="o">=</span><span class="n">coord</span><span class="o">.</span><span class="n">coord_system</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">updated_coord</span></div>


<div class="viewcode-block" id="get_field_attribute_name"><a class="viewcode-back" href="../../mip_convert/common.html#mip_convert.common.get_field_attribute_name">[docs]</a><span class="k">def</span> <span class="nf">get_field_attribute_name</span><span class="p">(</span><span class="n">header_element_name</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the name of the attribute on the</span>
<span class="sd">    :class:`iris.fileformats.pp.PPField` object and the item position</span>
<span class="sd">    corresponding to the name of the PP field header element.</span>

<span class="sd">    The names of the attributes on the</span>
<span class="sd">    :class:`iris.fileformats.pp.PPField` object do not correspond</span>
<span class="sd">    directly to the names of the PP field header elements. The values</span>
<span class="sd">    of the PP field header elements with the names e.g., &#39;lbuser1&#39;,</span>
<span class="sd">    &#39;lbuser2&#39;, etc., are stored as a tuple in a single attribute named</span>
<span class="sd">    e.g., &#39;lbuser&#39; on the :class:`iris.fileformats.pp.PPField` object.</span>

<span class="sd">    The item position uses 0-based indexing.</span>

<span class="sd">    :Examples:</span>

<span class="sd">    &gt;&gt;&gt; print(get_field_attribute_name(&#39;lbtim&#39;))</span>
<span class="sd">    (&#39;lbtim&#39;, None)</span>
<span class="sd">    &gt;&gt;&gt; print(get_field_attribute_name(&#39;lbuser4&#39;))</span>
<span class="sd">    (&#39;lbuser&#39;, 3)</span>

<span class="sd">    :param header_element_name: the name of the PP field header element</span>
<span class="sd">    :type header_element_name: string</span>
<span class="sd">    :returns: the name of the attribute on the</span>
<span class="sd">        :class:`iris.fileformats.pp.PPField` object and the item</span>
<span class="sd">        position</span>
<span class="sd">    :rtype: a tuple containing a string and an integer</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">field_attribute_name</span> <span class="o">=</span> <span class="n">header_element_name</span>
    <span class="n">item_position</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">header_element_name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">FIELD_ATTRIBUTE_NAMES_WITH_TUPLE_VALUE</span><span class="p">):</span>
        <span class="n">pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(^[a-z]*)([0-9]$)&#39;</span><span class="p">)</span>
        <span class="n">match</span> <span class="o">=</span> <span class="n">pattern</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">header_element_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
            <span class="n">field_attribute_name</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">item_position</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">field_attribute_name</span><span class="p">,</span> <span class="n">item_position</span></div>


<div class="viewcode-block" id="validate_latitudes"><a class="viewcode-back" href="../../mip_convert/common.html#mip_convert.common.validate_latitudes">[docs]</a><span class="k">def</span> <span class="nf">validate_latitudes</span><span class="p">(</span><span class="n">latitudes</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the validated latitudes.</span>

<span class="sd">    :Example:</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; latitudes = np.array(</span>
<span class="sd">    ...     [-90.001, -90.0001, -89.9999, -89.9, 89.9, 89.9999, 90.0, 90.0001])</span>
<span class="sd">    &gt;&gt;&gt; validate_latitudes(latitudes)</span>
<span class="sd">    array([-90.    , -90.    , -89.9999, -89.9   ,  89.9   ,  89.9999,</span>
<span class="sd">            90.    ,  90.    ])</span>

<span class="sd">    :param latitudes: latitudes to be validated</span>
<span class="sd">    :type latitudes: Numpy array</span>
<span class="sd">    :return: the validated latitudes</span>
<span class="sd">    :rtype: Numpy array</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">minimum_latitude</span> <span class="o">=</span> <span class="o">-</span><span class="mf">90.</span>
    <span class="n">maximum_latitude</span> <span class="o">=</span> <span class="mf">90.</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">latitudes</span><span class="p">[</span><span class="n">latitudes</span> <span class="o">&lt;</span> <span class="n">minimum_latitude</span><span class="p">]</span> <span class="o">=</span> <span class="n">minimum_latitude</span>
        <span class="n">latitudes</span><span class="p">[</span><span class="n">latitudes</span> <span class="o">&gt;</span> <span class="n">maximum_latitude</span><span class="p">]</span> <span class="o">=</span> <span class="n">maximum_latitude</span>
    <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">return</span> <span class="n">latitudes</span></div>


<span class="k">def</span> <span class="nf">guess_bounds_if_needed</span><span class="p">(</span><span class="n">coord</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Guess the bounds on a coordinate if not already present</span>
<span class="sd">    and bring the latitude bounds in range as necessary.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    coord: :class:iris.coords.DimCoord</span>
<span class="sd">         A coordinate to check for bounds.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">coord</span><span class="o">.</span><span class="n">has_bounds</span><span class="p">():</span>
        <span class="n">coord</span><span class="o">.</span><span class="n">guess_bounds</span><span class="p">()</span>

    <span class="k">if</span> <span class="s1">&#39;latitude&#39;</span> <span class="ow">in</span> <span class="n">coord</span><span class="o">.</span><span class="n">name</span><span class="p">():</span>
        <span class="n">lat_bounds</span> <span class="o">=</span> <span class="n">coord</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">coord</span><span class="o">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="n">validate_latitudes</span><span class="p">(</span><span class="n">lat_bounds</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">pretty_print_pairs</span><span class="p">(</span><span class="n">pairs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the pairs nicely formatted for logging.</span>

<span class="sd">    The tuples in the list provided to the ``pairs`` parameter contain</span>
<span class="sd">    only two values in the form ``[(key1, value1), (key2, value2)]``.</span>

<span class="sd">    :param pairs: the pairs to be printed</span>
<span class="sd">    :type pairs: list of tuples</span>
<span class="sd">    :return: the nicely formatted pairs</span>
<span class="sd">    :rtype: string</span>

<span class="sd">    :Example:</span>

<span class="sd">    &gt;&gt;&gt; pairs = [(&#39;this&#39;, &#39;that&#39;), (4, 5), (&#39;hello&#39;, 2)]</span>
<span class="sd">    &gt;&gt;&gt; print(pretty_print_pairs(pairs))</span>
<span class="sd">    &quot;this=that&quot;, &quot;4=5&quot;, &quot;hello=2&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;&quot;</span><span class="si">{0}</span><span class="s1">=</span><span class="si">{1}</span><span class="s1">&quot;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_filter_input</span><span class="p">(</span><span class="n">input_variables</span><span class="p">,</span> <span class="n">constants</span><span class="p">):</span>
    <span class="n">trim_item0</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">input_variables</span><span class="p">))</span>
    <span class="n">filtered</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">trim_item0</span><span class="p">:</span>
        <span class="c1"># Exclude duplicates, constants and numerical values.</span>
        <span class="n">duplicate</span> <span class="o">=</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">filtered</span>
        <span class="n">constant</span> <span class="o">=</span> <span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">constants</span>
        <span class="n">numerical</span> <span class="o">=</span> <span class="n">_is_number</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">duplicate</span> <span class="ow">or</span> <span class="n">constant</span> <span class="ow">or</span> <span class="n">numerical</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">filtered</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">count</span><span class="p">,</span> <span class="p">(</span><span class="n">item1</span><span class="p">,</span> <span class="n">item2</span><span class="p">,</span> <span class="n">item3</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">filtered</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">count</span><span class="p">,</span> <span class="n">item1</span><span class="p">,</span> <span class="n">item2</span><span class="p">,</span> <span class="n">item3</span>


<span class="k">def</span> <span class="nf">_is_number</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return True if value looks like a number.&quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">_is_stash</span><span class="p">(</span><span class="n">term</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return True if term looks like a |STASH code|.&quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">stash</span> <span class="o">=</span> <span class="n">STASH</span><span class="o">.</span><span class="n">from_msi</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">stash</span><span class="o">.</span><span class="n">is_valid</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">raw_to_value</span><span class="p">(</span><span class="n">type_map_func</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">raw_value</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the ``raw_value`` converted to correct type.</span>

<span class="sd">    :param type_map_func: function returning map of keys to type</span>
<span class="sd">                          and multiplicity</span>
<span class="sd">    :type type_map_func: function</span>
<span class="sd">    :param key: the key that specifies the type conversion to perform</span>
<span class="sd">    :type key: str</span>
<span class="sd">    :param raw_value: the raw value to convert</span>
<span class="sd">    :type raw_value: str</span>
<span class="sd">    :return: the ``raw_value`` converted to correct type</span>
<span class="sd">    :rtype: str, int, float list depending on ``type_map_func``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">type_map</span> <span class="o">=</span> <span class="n">type_map_func</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">raw_value</span> <span class="o">==</span> <span class="s1">&#39;None&#39;</span><span class="p">:</span>
        <span class="n">value</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ptype</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">config_option</span><span class="p">,</span> <span class="n">option_info</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">type_map</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">config_option</span><span class="p">):</span>
                <span class="n">ptype</span> <span class="o">=</span> <span class="n">option_info</span><span class="p">[</span><span class="s1">&#39;python_type&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">option_info</span><span class="p">[</span><span class="s1">&#39;value_type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;multiple&#39;</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="n">ptype</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">raw_value</span><span class="o">.</span><span class="n">split</span><span class="p">()]</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">ptype</span><span class="p">(</span><span class="n">raw_value</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ptype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">config_function</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{module}</span><span class="s1">.</span><span class="si">{name}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">module</span><span class="o">=</span><span class="n">type_map_func</span><span class="o">.</span><span class="vm">__module__</span><span class="p">,</span>
                <span class="n">name</span><span class="o">=</span><span class="n">type_map_func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s1">&#39;No configuration information available for &quot;</span><span class="si">{key}</span><span class="s1">&quot;; please edit the &quot;</span><span class="si">{config_function}</span><span class="s1">&quot; function&#39;</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="n">message</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span> <span class="n">config_function</span><span class="o">=</span><span class="n">config_function</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">value</span>


<span class="k">class</span> <span class="nc">Loadable</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Instances of this class represent an |input variable| with possible</span>
<span class="sd">    constraints on level etc.  The |input variables| are in files on</span>
<span class="sd">    disk or in mass.  A Loadable does not know where it is or how to</span>
<span class="sd">    extract it (from the file or mass).  This is left to the client</span>
<span class="sd">    code.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">tokens</span><span class="p">,</span> <span class="n">number</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param name: name of the constraint - the form it appears in</span>
<span class="sd">                     an expression</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param tokens: the names, comparators and values of the</span>
<span class="sd">                       diagnostic identifiers (stash, lbproc etc.)</span>
<span class="sd">        :type tokens: list of tuples</span>
<span class="sd">        :param number: number of this |input variable| in expression.</span>

<span class="sd">        :Example:</span>
<span class="sd">        &gt;&gt;&gt; loadable = Loadable(</span>
<span class="sd">        ...     &#39;m01s01i001&#39;, [(&#39;stash&#39;, &#39;=&#39;, &#39;m01s01i001&#39;)], 1)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tokens</span> <span class="o">=</span> <span class="n">tokens</span>
        <span class="n">constraint</span> <span class="o">=</span> <span class="n">itemgetter</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_add_default_lbtim</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constraints</span> <span class="o">=</span> <span class="p">[</span><span class="n">constraint</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tokens</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constraint</span> <span class="o">=</span> <span class="s1">&#39;constraint</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">number</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">tokens</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">tokens</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;Loadable(</span><span class="si">{}</span><span class="s1">, </span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tokens</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tokens</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a string form of the loadable.&quot;&quot;&quot;</span>
        <span class="n">constraint_info</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_info</span><span class="p">(</span><span class="n">token</span><span class="p">)</span> <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tokens</span><span class="p">]</span>
        <span class="k">return</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">constraint_info</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">token</span><span class="p">):</span>
        <span class="n">comparator_str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span> <span class="k">if</span> <span class="n">token</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;=&#39;</span> <span class="k">else</span> <span class="n">token</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">template</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{constraint}</span><span class="s1">: </span><span class="si">{comparator}{value}</span><span class="s1">&#39;</span>
        <span class="k">return</span> <span class="n">template</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">constraint</span><span class="o">=</span><span class="n">token</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">comparator</span><span class="o">=</span><span class="n">comparator_str</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">token</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">is_pp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True of the loadable is from a pp file&quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">validated_constraints</span> <span class="o">=</span> <span class="p">[</span><span class="n">supported_pp_constraint</span>
                                 <span class="k">for</span> <span class="n">supported_pp_constraint</span> <span class="ow">in</span> <span class="n">SUPPORTED_PP_CONSTRAINTS</span>
                                 <span class="k">for</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constraints</span> <span class="k">if</span> <span class="n">constraint</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">supported_pp_constraint</span><span class="p">)</span>
                                 <span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">SUPPORTED_PP_CONSTRAINTS</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">validated_constraints</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_add_default_lbtim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add an lbtim constraint if one does not exist already. Default to</span>
<span class="sd">        LBTIM_DEFAULT_MEAN (122) for most time mean fields, or</span>
<span class="sd">        LBTIM_DEFAULT_POINT (12) for instantaneous (lbproc=0).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="n">lbproc</span> <span class="o">=</span> <span class="n">LBPROC_DEFAULT</span>
        <span class="n">stash</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">token_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tokens</span><span class="p">:</span>
            <span class="n">token_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">token</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">token</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;lbproc&#39;</span><span class="p">:</span>
                <span class="n">lbproc</span> <span class="o">=</span> <span class="n">token</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">token</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;stash&#39;</span><span class="p">:</span>
                <span class="n">stash</span> <span class="o">=</span> <span class="n">token</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_pp</span><span class="p">()</span> <span class="ow">or</span> <span class="s1">&#39;lbtim&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constraints</span> <span class="ow">or</span> <span class="n">stash</span> <span class="ow">in</span> <span class="n">ANCIL_VARIABLES</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">expected_lbtim_ia</span><span class="p">,</span> <span class="n">expected_lbtim_ib</span> <span class="o">=</span> <span class="n">LBTIM_DEFAULT_MEAN</span>
        <span class="k">if</span> <span class="n">lbproc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">expected_lbtim_ia</span><span class="p">,</span> <span class="n">expected_lbtim_ib</span> <span class="o">=</span> <span class="n">LBTIM_DEFAULT_POINT</span>
        <span class="k">if</span> <span class="s1">&#39;lbtim_ia&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">token_list</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;adding constraint lbtim_ia = &quot;</span><span class="si">{}</span><span class="s1">&quot; to loadable &quot;</span><span class="si">{}</span><span class="s1">&quot;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">expected_lbtim_ia</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tokens</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;lbtim_ia&#39;</span><span class="p">,</span> <span class="s1">&#39;=&#39;</span><span class="p">,</span> <span class="n">expected_lbtim_ia</span><span class="p">))</span>
        <span class="k">if</span> <span class="s1">&#39;lbtim_ib&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">token_list</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;adding constraint lbtim_ib = &quot;</span><span class="si">{}</span><span class="s1">&quot; to loadable &quot;</span><span class="si">{}</span><span class="s1">&quot;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">expected_lbtim_ib</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tokens</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;lbtim_ib&#39;</span><span class="p">,</span> <span class="s1">&#39;=&#39;</span><span class="p">,</span> <span class="n">expected_lbtim_ib</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">stash</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return only the STASH code&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_pp</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constraints</span><span class="p">)[</span><span class="s1">&#39;stash&#39;</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_parse_bracket_constaints</span><span class="p">(</span><span class="n">all_other_constraints</span><span class="p">):</span>
    <span class="n">other_constraints</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">all_other_constraints</span><span class="p">:</span>
        <span class="c1"># Break down the other constraints into individual</span>
        <span class="c1"># constraints.</span>
        <span class="n">constraint_name_pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;([\w]+)&#39;</span>
        <span class="n">constraint_value_pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;([\w\s:.()]+)&#39;</span>
        <span class="n">comparator_pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;([=&lt;])&#39;</span>
        <span class="n">pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\s*&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">constraint_name_pattern</span><span class="p">,</span> <span class="n">comparator_pattern</span><span class="p">,</span> <span class="n">constraint_value_pattern</span><span class="p">]))</span>
        <span class="n">other_constraints</span> <span class="o">=</span> <span class="n">pattern</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">all_other_constraints</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">other_constraints</span>


<span class="k">def</span> <span class="nf">_parse_namelike_constraint</span><span class="p">(</span><span class="n">first_constraint</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">_is_stash</span><span class="p">(</span><span class="n">first_constraint</span><span class="p">):</span>
        <span class="n">constraint_name</span> <span class="o">=</span> <span class="s1">&#39;stash&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">constraint_name</span> <span class="o">=</span> <span class="s1">&#39;variable_name&#39;</span>
    <span class="n">constraints</span> <span class="o">=</span> <span class="p">[(</span><span class="n">constraint_name</span><span class="p">,</span> <span class="s1">&#39;=&#39;</span><span class="p">,</span> <span class="n">first_constraint</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">constraints</span>


<span class="k">def</span> <span class="nf">_parse_to_components</span><span class="p">(</span><span class="n">expression</span><span class="p">):</span>
    <span class="c1"># Break down the expression into &#39;input variables&#39;.</span>
    <span class="c1"># group1 is the function, if one exists.</span>
    <span class="n">function_pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;([\w]+\s*\([\(\s\-]*)?&#39;</span>

    <span class="c1"># group3 includes the first constraint i.e., STASH code or variable</span>
    <span class="c1">#   name, constants and numerical values (the latter two are</span>
    <span class="c1">#   filtered out later). Ignore function arguments and values</span>
    <span class="c1">#   (strings followed by an equals sign or preceded by an equals</span>
    <span class="c1">#   sign and a quote, e.g. arg=&quot;value&quot;).</span>
    <span class="n">first_constraint_pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;(?&lt;!=[</span><span class="se">\&#39;</span><span class="s1">&quot;]</span><span class="si">{1}</span><span class="s1">)\b(\w+)\b(?!=)&#39;</span>

    <span class="c1"># group4 is the other constraints i.e., optional additional</span>
    <span class="c1">#   constraints provided in square brackets.</span>
    <span class="n">other_constraints_pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;(\[[\w=&lt;,\s:.()]*\])?&#39;</span>

    <span class="c1"># group2 is the &#39;input variable&#39; i.e., group3 + group4.</span>
    <span class="n">input_variables_pattern</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">(</span><span class="si">{}{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">function_pattern</span><span class="p">,</span> <span class="n">first_constraint_pattern</span><span class="p">,</span> <span class="n">other_constraints_pattern</span><span class="p">)</span>
    <span class="n">pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">input_variables_pattern</span><span class="p">)</span>

    <span class="n">input_variables</span> <span class="o">=</span> <span class="n">pattern</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">expression</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">input_variables</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
            <span class="s1">&#39;Invalid expression: &quot;</span><span class="si">{}</span><span class="s1">&quot;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">expression</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">input_variables</span>


<span class="k">def</span> <span class="nf">_check_constraints_supported</span><span class="p">(</span><span class="n">constraints</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">constraint_name</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">constraints</span><span class="p">:</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">get_supported_constraint</span><span class="p">(</span><span class="n">constraint_name</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_check_lt</span><span class="p">(</span><span class="n">constraints</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">comp</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">constraints</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">comp</span> <span class="o">==</span> <span class="s1">&#39;&lt;&#39;</span> <span class="ow">and</span> <span class="n">name</span> <span class="o">!=</span> <span class="s1">&#39;depth&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;&quot;&lt;&quot; only supported for depth&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">comp</span> <span class="o">==</span> <span class="s1">&#39;&lt;&#39;</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;&quot;&lt;&quot; only supported for scalars&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_expand_values</span><span class="p">(</span><span class="n">constraints</span><span class="p">,</span> <span class="n">constants</span><span class="p">,</span> <span class="n">mappings_config</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">_expander</span><span class="p">(</span><span class="n">option</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">raw_to_value</span><span class="p">(</span><span class="n">mappings_config</span><span class="p">,</span> <span class="n">option</span><span class="p">,</span> <span class="n">constants</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>

    <span class="k">return</span> <span class="p">[(</span><span class="n">option</span><span class="p">,</span> <span class="n">comp</span><span class="p">,</span> <span class="n">_expander</span><span class="p">(</span><span class="n">option</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span> <span class="k">for</span> <span class="n">option</span><span class="p">,</span> <span class="n">comp</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">constraints</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">parse_to_loadables</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">constants</span><span class="p">,</span> <span class="n">mappings_config</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the parsed |model to MIP mapping| expression.</span>

<span class="sd">    :param expression: the |model to MIP mapping| expression as defined</span>
<span class="sd">        in the |model to MIP mapping| configuration files</span>
<span class="sd">    :type expression: string</span>
<span class="sd">    :param constants: the constants that may be used in the expression</span>
<span class="sd">    :type constants: dictionary</span>
<span class="sd">    :param mappings_config: information on the type and multiplicity of</span>
<span class="sd">        terms in expression</span>
<span class="sd">    :type: function</span>
<span class="sd">    :return: the parsed |model to MIP mapping| expression</span>
<span class="sd">    :rtype: list of :class:`mip_convert.common.Loadable`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">input_variables</span> <span class="o">=</span> <span class="n">_parse_to_components</span><span class="p">(</span><span class="n">expression</span><span class="p">)</span>
    <span class="n">loadables</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">relevant_values</span> <span class="o">=</span> <span class="n">_filter_input</span><span class="p">(</span><span class="n">input_variables</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">constants</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
    <span class="k">for</span> <span class="n">count</span><span class="p">,</span> <span class="n">input_variable</span><span class="p">,</span> <span class="n">first_constraint</span><span class="p">,</span> <span class="n">all_other_constraints</span> <span class="ow">in</span> <span class="n">relevant_values</span><span class="p">:</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="p">(</span><span class="n">_parse_namelike_constraint</span><span class="p">(</span><span class="n">first_constraint</span><span class="p">)</span> <span class="o">+</span> <span class="n">_parse_bracket_constaints</span><span class="p">(</span><span class="n">all_other_constraints</span><span class="p">))</span>

        <span class="n">_check_constraints_supported</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="n">_expand_values</span><span class="p">(</span><span class="n">tokens</span><span class="p">,</span> <span class="n">constants</span><span class="p">,</span> <span class="n">mappings_config</span><span class="p">)</span>
        <span class="n">_check_lt</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>

        <span class="n">loadables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Loadable</span><span class="p">(</span><span class="n">input_variable</span><span class="p">,</span> <span class="n">tokens</span><span class="p">,</span> <span class="n">count</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">loadables</span>


<span class="k">def</span> <span class="nf">get_supported_constraint</span><span class="p">(</span><span class="n">constraint</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the name of the constraint as specified in the</span>
<span class="sd">    SUPPORTED_CONSTRAINTS list.</span>

<span class="sd">    :param constraint: the name of the constraint, which may have a</span>
<span class="sd">        numerical suffix</span>
<span class="sd">    :type constraint_name: string</span>
<span class="sd">    :return: the supported name of the constraint</span>
<span class="sd">    :rtype: string</span>

<span class="sd">    :examples:</span>

<span class="sd">    &gt;&gt;&gt; get_supported_constraint(&#39;lbproc&#39;)</span>
<span class="sd">    &#39;lbproc&#39;</span>
<span class="sd">    &gt;&gt;&gt; get_supported_constraint(&#39;lbtim1&#39;)</span>
<span class="sd">    &#39;lbtim&#39;</span>
<span class="sd">    &gt;&gt;&gt; get_supported_constraint(&#39;blev999&#39;)</span>
<span class="sd">    &#39;blev&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">supported_constraint</span> <span class="ow">in</span> <span class="n">SUPPORTED_CONSTRAINTS</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">constraint</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">supported_constraint</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">supported_constraint</span>
    <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Constraint &quot;</span><span class="si">{constraint}</span><span class="s1">&quot; is not supported&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">constraint</span><span class="o">=</span><span class="n">constraint</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">is_auxiliary_coord</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="n">coord_name</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return whether a coordinate in a cube is an auxiliary coordinate.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cube: :class:`iris.cube.Cube`</span>
<span class="sd">        The cube.</span>
<span class="sd">    coord_name: string</span>
<span class="sd">        The name of the coordinate.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    boolean</span>
<span class="sd">        Whether ``coord_name`` exists as an auxiliary coordinate in the</span>
<span class="sd">        ``cube``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">cube</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="n">coord_name</span><span class="p">,</span> <span class="n">dim_coords</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">except</span> <span class="n">iris</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">CoordinateNotFoundError</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">has_auxiliary_latitude_longitude</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="n">data_dimensions</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return whether the latitude and longitude coordinates in a cube</span>
<span class="sd">    are auxilliary coordinates with the dimensions provided.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cube: :class:`iris.cube.Cube`</span>
<span class="sd">        The cube.</span>
<span class="sd">    data_dimensions: int</span>
<span class="sd">        The number of dimensions of the data in the latitude and</span>
<span class="sd">        longitude coordinates.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    boolean</span>
<span class="sd">        Whether the latitude and longitude coordinates exist as</span>
<span class="sd">        auxiliary coordinates in the ``cube`` and have dimensions</span>
<span class="sd">        ``data_dimensions``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">is_auxiliary_coord</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="s1">&#39;longitude&#39;</span><span class="p">)</span> <span class="ow">and</span>
            <span class="n">is_auxiliary_coord</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="s1">&#39;latitude&#39;</span><span class="p">)</span> <span class="ow">and</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">cube</span><span class="o">.</span><span class="n">coord_dims</span><span class="p">(</span><span class="s1">&#39;latitude&#39;</span><span class="p">))</span> <span class="o">==</span> <span class="n">data_dimensions</span> <span class="ow">and</span>
            <span class="n">cube</span><span class="o">.</span><span class="n">coord_dims</span><span class="p">(</span><span class="s1">&#39;latitude&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="n">cube</span><span class="o">.</span><span class="n">coord_dims</span><span class="p">(</span><span class="s1">&#39;longitude&#39;</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">remove_extra_time_axis</span><span class="p">(</span><span class="n">input_variable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Remove the extra time axis from the |input variable| provided by</span>
<span class="sd">    the ``input_variable`` parameter.</span>

<span class="sd">    If two or more time coordinates with the same standard name exist</span>
<span class="sd">    in the |input variable|, the auxiliary time coordinates are</span>
<span class="sd">    removed. This situation occurs when neither the `time_counter` nor</span>
<span class="sd">    `time_centered` coordinates in |model output files| from NEMO is a</span>
<span class="sd">    record.</span>

<span class="sd">    Otherwise, remove the `time_counter` coordinate. This situation</span>
<span class="sd">    occurs when the `time_counter` coordinate in |model output files|</span>
<span class="sd">    from NEMO is a record; the points are sequential whole numbers</span>
<span class="sd">    corresponding to the number of time slices in the |input variable|,</span>
<span class="sd">    which prevents concatenation (see</span>
<span class="sd">    https://groups.google.com/forum/#!topic/scitools-iris/BHhKs_DQSUA).</span>
<span class="sd">    In this case, the `time_counter` coordinate is a dimension</span>
<span class="sd">    coordinate, so the remaining auxiliary time coordinate is promoted</span>
<span class="sd">    to a dimension coordinate.</span>

<span class="sd">    :param input_variable: the |input variable|</span>
<span class="sd">    :type input_variable: :class:`iris.cube.Cube`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">count_time_axes</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">time_axes_names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">input_variable</span><span class="o">.</span><span class="n">coords</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">iris</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">guess_coord_axis</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;T&#39;</span><span class="p">:</span>
            <span class="n">count_time_axes</span> <span class="o">=</span> <span class="n">count_time_axes</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">time_axes_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coord</span><span class="o">.</span><span class="n">standard_name</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">count_time_axes</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">time_axes_names</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">aux_coord</span> <span class="ow">in</span> <span class="n">input_variable</span><span class="o">.</span><span class="n">coords</span><span class="p">(</span><span class="n">dim_coords</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">iris</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">guess_coord_axis</span><span class="p">(</span><span class="n">aux_coord</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;T&#39;</span><span class="p">:</span>
                <span class="n">input_variable</span><span class="o">.</span><span class="n">remove_coord</span><span class="p">(</span><span class="n">aux_coord</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">input_variable</span><span class="o">.</span><span class="n">coords</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">coord</span><span class="o">.</span><span class="n">var_name</span> <span class="o">==</span> <span class="s1">&#39;time_counter&#39;</span><span class="p">:</span>
                <span class="n">input_variable</span><span class="o">.</span><span class="n">remove_coord</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">promote_aux_time_coord_to_dim</span><span class="p">(</span><span class="n">input_variable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    If appropriate promote an auxilliary time coordinate</span>
<span class="sd">    to a dimension coordinate. Note that changes are made</span>
<span class="sd">    to the supplied cube in place.</span>

<span class="sd">    :param input_variable: the |input variable|</span>
<span class="sd">    :type input_variable: :class:`iris.cube.Cube`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">aux_coord</span> <span class="ow">in</span> <span class="n">input_variable</span><span class="o">.</span><span class="n">coords</span><span class="p">(</span><span class="n">dim_coords</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">aux_coord</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">DimCoord</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">iris</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">guess_coord_axis</span><span class="p">(</span><span class="n">aux_coord</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;T&#39;</span><span class="p">:</span>
                <span class="n">iris</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">promote_aux_coord_to_dim_coord</span><span class="p">(</span><span class="n">input_variable</span><span class="p">,</span> <span class="n">aux_coord</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">replace_coordinates</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="n">replacement_coordinates</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Replace the points and bounds of the coordinates in the cube</span>
<span class="sd">    provided to the ``cube`` parameter with the points and bounds from</span>
<span class="sd">    the area cubes provided to the ``replacement_coordinates``</span>
<span class="sd">    parameter.</span>

<span class="sd">    The ``var_name`` is used to determine whether the replacement</span>
<span class="sd">    should occur.</span>

<span class="sd">    :param cube: the cube with values to be replaced</span>
<span class="sd">    :type cube: :class:`iris.cube.Cube`</span>
<span class="sd">    :param replacement_coordinates: the area cubes containing the</span>
<span class="sd">        replacement coordinates</span>
<span class="sd">    :type replacement_coordinates: :class:`iris.cube.CubeList`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">area_cube</span> <span class="ow">in</span> <span class="n">replacement_coordinates</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">area_coord</span> <span class="ow">in</span> <span class="n">area_cube</span><span class="o">.</span><span class="n">coords</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">cube</span><span class="o">.</span><span class="n">coords</span><span class="p">(</span><span class="n">var_name</span><span class="o">=</span><span class="n">area_coord</span><span class="o">.</span><span class="n">var_name</span><span class="p">):</span>
                <span class="n">coord</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="n">var_name</span><span class="o">=</span><span class="n">area_coord</span><span class="o">.</span><span class="n">var_name</span><span class="p">)</span>
                <span class="n">coord</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">area_coord</span><span class="o">.</span><span class="n">points</span>
                <span class="n">coord</span><span class="o">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="n">area_coord</span><span class="o">.</span><span class="n">bounds</span>


<span class="k">def</span> <span class="nf">MIP_to_model_axis_name_mapping</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the name of the coordinate that should exist in a cube given</span>
<span class="sd">    the name of the axis from the |MIP table|.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="s1">&#39;dbze&#39;</span><span class="p">:</span> <span class="s1">&#39;pseudo_level&#39;</span><span class="p">,</span>
        <span class="s1">&#39;iceband&#39;</span><span class="p">:</span> <span class="s1">&#39;category maximum thickness&#39;</span><span class="p">,</span>
        <span class="s1">&#39;site&#39;</span><span class="p">:</span> <span class="s1">&#39;site_number&#39;</span><span class="p">,</span>
        <span class="s1">&#39;typebare&#39;</span><span class="p">:</span> <span class="s1">&#39;pseudo_level&#39;</span><span class="p">,</span>
        <span class="s1">&#39;scatratio&#39;</span><span class="p">:</span> <span class="s1">&#39;pseudo_level&#39;</span><span class="p">,</span>
        <span class="s1">&#39;sza5&#39;</span><span class="p">:</span> <span class="s1">&#39;solar_zenith_angle&#39;</span><span class="p">,</span>
        <span class="s1">&#39;landUse&#39;</span><span class="p">:</span> <span class="s1">&#39;landUse&#39;</span><span class="p">,</span>
        <span class="s1">&#39;tau&#39;</span><span class="p">:</span> <span class="s1">&#39;atmosphere_optical_thickness_due_to_cloud&#39;</span><span class="p">,</span>
        <span class="s1">&#39;spectband&#39;</span><span class="p">:</span> <span class="s1">&#39;pseudo_level&#39;</span><span class="p">,</span>
        <span class="s1">&#39;basin&#39;</span><span class="p">:</span> <span class="s1">&#39;region&#39;</span><span class="p">,</span>
        <span class="s1">&#39;effectRadLi&#39;</span><span class="p">:</span> <span class="s1">&#39;height&#39;</span><span class="p">,</span>
        <span class="s1">&#39;effectRadIc&#39;</span><span class="p">:</span> <span class="s1">&#39;height&#39;</span><span class="p">,</span>
    <span class="p">}</span>


<span class="k">def</span> <span class="nf">eorca_resolution_to_mask_slice</span><span class="p">(</span><span class="n">model_id</span><span class="p">,</span> <span class="n">model_component</span><span class="p">,</span> <span class="n">substream</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return slice that would correspond to the misshapen top row of eORCA</span>
<span class="sd">    grid in a given resolution.</span>

<span class="sd">    :param model_id: model ID</span>
<span class="sd">    :type model_id: str</span>
<span class="sd">    :param model_component: model component (&#39;nemo&#39; or &#39;cice&#39;)</span>
<span class="sd">    :type model_component: string</span>
<span class="sd">    :param substream: substream name</span>
<span class="sd">    :type substream: string|None</span>
<span class="sd">    :returns: slice corresponding to the top row(s)</span>
<span class="sd">    :rtype: :class:`slice`|None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">plugin</span> <span class="o">=</span> <span class="n">PluginStore</span><span class="o">.</span><span class="n">instance</span><span class="p">()</span><span class="o">.</span><span class="n">get_plugin</span><span class="p">()</span>
        <span class="n">grid_info</span> <span class="o">=</span> <span class="n">plugin</span><span class="o">.</span><span class="n">grid_info</span><span class="p">(</span><span class="n">model_id</span><span class="p">,</span> <span class="n">GridType</span><span class="o">.</span><span class="n">OCEAN</span><span class="p">)</span>
        <span class="n">masks</span> <span class="o">=</span> <span class="n">grid_info</span><span class="o">.</span><span class="n">masks</span><span class="p">[</span><span class="n">substream</span> <span class="k">if</span> <span class="n">substream</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">model_component</span><span class="p">]</span>
        <span class="n">mask_slice</span> <span class="o">=</span> <span class="n">masks</span><span class="o">.</span><span class="n">slice</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="n">mask_slice</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="n">mask_slice</span>


<span class="k">def</span> <span class="nf">cmp_to_key</span><span class="p">(</span><span class="n">mycmp</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a callable which can compare two objects using a provided function emulating Python2 cmp().</span>

<span class="sd">    This provides a way to translate Python2 dictionary sorting with cmp function into Python3 sort-by-key method.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mycmp: function</span>
<span class="sd">        Function providing functionality comparable to Python2 cmp()</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    : class</span>
<span class="sd">        Class which may be instantiated with objects that need to be compared, and implementing standard comparison</span>
<span class="sd">        operators for these objects.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">class</span> <span class="nc">K</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">obj</span> <span class="o">=</span> <span class="n">obj</span>

        <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">mycmp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span>

        <span class="k">def</span> <span class="fm">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">mycmp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>

        <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">mycmp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>

        <span class="k">def</span> <span class="fm">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">mycmp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span>

        <span class="k">def</span> <span class="fm">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">mycmp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span>

        <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">mycmp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">K</span>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">MIP Convert 2.3.3.dev0+main.2f65f7c-M documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">mip_convert.common</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright British Crown 2015-2021, Met Office.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.2.0.
    </div>
  </body>
</html>