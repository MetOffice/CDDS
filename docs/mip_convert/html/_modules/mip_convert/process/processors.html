
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>mip_convert.process.processors &#8212; MIP Convert 2.4.5 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/nature.css" />
    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <link rel="author" title="About these documents" href="../../../about.html" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">MIP Convert 2.4.5 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">mip_convert.process.processors</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for mip_convert.process.processors</h1><div class="highlight"><pre>
<span></span><span class="c1"># (C) British Crown Copyright 2016-2022, Met Office.</span>
<span class="c1"># Please see LICENSE.rst for license details.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Module containing processor functions.  These processors can be referred</span>
<span class="sd">to from |model to MIP mapping| expressions.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">chain</span>
<span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">regex</span> <span class="k">as</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">cf_units</span> <span class="kn">import</span> <span class="n">Unit</span>
<span class="kn">import</span> <span class="nn">iris</span>
<span class="kn">from</span> <span class="nn">iris.analysis</span> <span class="kn">import</span> <span class="n">MEAN</span><span class="p">,</span> <span class="n">SUM</span><span class="p">,</span> <span class="n">MAX</span>
<span class="kn">from</span> <span class="nn">iris.analysis.cartography</span> <span class="kn">import</span> <span class="n">area_weights</span>
<span class="kn">from</span> <span class="nn">iris.coord_categorisation</span> <span class="kn">import</span> <span class="p">(</span><span class="n">add_categorised_coord</span><span class="p">,</span> <span class="n">add_hour</span><span class="p">,</span>
                                       <span class="n">add_month_number</span><span class="p">,</span> <span class="n">add_year</span><span class="p">,</span>
                                       <span class="n">add_day_of_month</span><span class="p">,</span> <span class="n">add_hour</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">iris.exceptions</span> <span class="kn">import</span> <span class="n">CoordinateNotFoundError</span>
<span class="kn">from</span> <span class="nn">iris.util</span> <span class="kn">import</span> <span class="n">guess_coord_axis</span>
<span class="kn">from</span> <span class="nn">iris.util</span> <span class="kn">import</span> <span class="n">equalise_attributes</span>

<span class="kn">from</span> <span class="nn">mip_convert.common</span> <span class="kn">import</span> <span class="n">guess_bounds_if_needed</span>
<span class="kn">from</span> <span class="nn">mip_convert.constants</span> <span class="kn">import</span> <span class="p">(</span><span class="n">JPDFTAUREICEMODIS_POINTS</span><span class="p">,</span> <span class="n">JPDFTAUREICEMODIS_BOUNDS</span><span class="p">,</span>
                                   <span class="n">JPDFTAURELIQMODIS_POINTS</span><span class="p">,</span> <span class="n">JPDFTAURELIQMODIS_BOUNDS</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_check_daily_cube</span><span class="p">(</span><span class="n">cube</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Raise an exception if the cube does not contain daily statistics.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_start_month_at_index</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if date at index in times is at start of month.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">date</span> <span class="o">=</span> <span class="n">times</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">num2date</span><span class="p">(</span><span class="n">times</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">date</span><span class="o">.</span><span class="n">day</span><span class="p">,</span> <span class="n">date</span><span class="o">.</span><span class="n">hour</span><span class="p">,</span> <span class="n">date</span><span class="o">.</span><span class="n">minute</span><span class="p">,</span> <span class="n">date</span><span class="o">.</span><span class="n">second</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_is_daily</span><span class="p">(</span><span class="n">times</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if times is a coordinate for daily data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">st_units</span> <span class="o">=</span> <span class="s1">&#39;days since </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">times</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">days_since</span> <span class="o">=</span> <span class="n">Unit</span><span class="p">(</span><span class="n">st_units</span><span class="p">,</span> <span class="n">calendar</span><span class="o">=</span><span class="n">times</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">calendar</span><span class="p">)</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="n">times</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">times</span><span class="o">.</span><span class="n">bounds</span><span class="p">,</span> <span class="n">days_since</span><span class="p">)</span>
        <span class="n">time_deltas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">time_deltas</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_range_bounds_months</span><span class="p">(</span><span class="n">times</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if the times coordinate spans a whole number of months.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">beg_index</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">end_index</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">_start_month_at_index</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="p">(</span><span class="n">beg_index</span><span class="p">,</span> <span class="n">end_index</span><span class="p">))</span>

    <span class="n">times</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">times</span><span class="o">.</span><span class="n">bounds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cube should have time coordinate with bounds.&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">_is_daily</span><span class="p">(</span><span class="n">times</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cube should have daily data&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">times</span><span class="o">.</span><span class="n">is_contiguous</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cube should have no gaps along time coordinate&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">_range_bounds_months</span><span class="p">(</span><span class="n">times</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cube should cover a whole number of months&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_monthly_mean</span><span class="p">(</span><span class="n">cube</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the monthly mean the cube.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">add_month_number</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;month&#39;</span><span class="p">)</span>
    <span class="n">add_year</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;year&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cube</span><span class="o">.</span><span class="n">aggregated_by</span><span class="p">([</span><span class="s1">&#39;month&#39;</span><span class="p">,</span> <span class="s1">&#39;year&#39;</span><span class="p">],</span> <span class="n">MEAN</span><span class="p">)</span>


<div class="viewcode-block" id="mon_mean_from_day"><a class="viewcode-back" href="../../../mip_convert/process/processors.html#mip_convert.process.processors.mon_mean_from_day">[docs]</a><span class="k">def</span> <span class="nf">mon_mean_from_day</span><span class="p">(</span><span class="n">cube</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate a monthly mean from a cube of daily statistics.</span>

<span class="sd">    This function can be used to calculate quantities such as the</span>
<span class="sd">    monthly mean daily minumum temperature.  It will raise an</span>
<span class="sd">    exception if the input cube does not look like a time series</span>
<span class="sd">    of daily statistics spanning a whole number of months.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cube: :class:`iris.cube.Cube`</span>
<span class="sd">        A cube of daily data.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    : :class:`iris.cube.Cube`</span>
<span class="sd">        A cube of monthly mean data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_check_daily_cube</span><span class="p">(</span><span class="n">cube</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_monthly_mean</span><span class="p">(</span><span class="n">cube</span><span class="p">)</span></div>


<div class="viewcode-block" id="mdi_to_zero"><a class="viewcode-back" href="../../../mip_convert/process/processors.html#mip_convert.process.processors.mdi_to_zero">[docs]</a><span class="k">def</span> <span class="nf">mdi_to_zero</span><span class="p">(</span><span class="n">cube</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Changes any values corresponding to missing data to zero.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cube: :class:`iris.cube.Cube`</span>
<span class="sd">        A cube with some missing data.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    : :class:`iris.cube.Cube`</span>
<span class="sd">        A cube with no missing data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Data will no longer be a masked array.</span>
    <span class="n">cube</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">fill_value</span><span class="o">=</span><span class="mf">0.</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cube</span></div>


<div class="viewcode-block" id="fix_parasol_sza_axis"><a class="viewcode-back" href="../../../mip_convert/process/processors.html#mip_convert.process.processors.fix_parasol_sza_axis">[docs]</a><span class="k">def</span> <span class="nf">fix_parasol_sza_axis</span><span class="p">(</span><span class="n">cube</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fixes the vertical axis of a PARASOL reflectance cube (m01s02i348).</span>
<span class="sd">    Changes the axis from geometric height to solar zenith angle.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cube: :class:`iris.cube.Cube`</span>
<span class="sd">        A cube with a geometric height vertical axis.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    : :class:`iris.cube.Cube`</span>
<span class="sd">        A cube with the correct vertical axis (solar zenith angle).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cube</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="s1">&#39;height&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s1">&#39;solar_zenith_angle&#39;</span><span class="p">)</span>
    <span class="n">sza</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="s1">&#39;solar_zenith_angle&#39;</span><span class="p">)</span>
    <span class="n">sza</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="s1">&#39;degree&#39;</span>
    <span class="n">sza</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">sza</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
    <span class="n">sza</span><span class="o">.</span><span class="n">attributes</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="n">cube</span></div>


<div class="viewcode-block" id="area_mean"><a class="viewcode-back" href="../../../mip_convert/process/processors.html#mip_convert.process.processors.area_mean">[docs]</a><span class="k">def</span> <span class="nf">area_mean</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="n">areacube</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate an area weighted mean of input cube</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cube: :class:`iris.cube.Cube`</span>
<span class="sd">        A cube with latitude/longitude coordinates</span>
<span class="sd">    areacube: :class:`iris.cube.Cube`</span>
<span class="sd">        A cube of grid cell areas</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    : :class:`iris.cube.Cube`</span>
<span class="sd">        The area mean cube.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">areacube</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">cube</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">cube</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">collapsed</span><span class="p">([</span><span class="s1">&#39;latitude&#39;</span><span class="p">,</span> <span class="s1">&#39;longitude&#39;</span><span class="p">],</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">MEAN</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">area</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cube</span></div>


<div class="viewcode-block" id="primavera_make_uva100m"><a class="viewcode-back" href="../../../mip_convert/process/processors.html#mip_convert.process.processors.primavera_make_uva100m">[docs]</a><span class="k">def</span> <span class="nf">primavera_make_uva100m</span><span class="p">(</span><span class="n">cube</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The model runs to generate the PRIMAVERA variables ua100m and</span>
<span class="sd">    va100m contain data on two levels because it wasn&#39;t known which</span>
<span class="sd">    level users would require when the model runs had to start. This</span>
<span class="sd">    function returns a cube on model level 4, which is now known to be</span>
<span class="sd">    the desired level. The coordinate ``level_height`` is renamed to</span>
<span class="sd">    ``height100m``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cube: :class:`iris.cube.Cube`</span>
<span class="sd">        A cube containing two levels.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    : :class:`iris.cube.Cube`</span>
<span class="sd">        A cube containing model level 4.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cube</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">iris</span><span class="o">.</span><span class="n">Constraint</span><span class="p">(</span><span class="n">model_level_number</span><span class="o">=</span><span class="mi">4</span><span class="p">))</span>
    <span class="n">cube</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="s1">&#39;level_height&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s1">&#39;height100m&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cube</span></div>


<div class="viewcode-block" id="scale_epflux"><a class="viewcode-back" href="../../../mip_convert/process/processors.html#mip_convert.process.processors.scale_epflux">[docs]</a><span class="k">def</span> <span class="nf">scale_epflux</span><span class="p">(</span><span class="n">cube_data</span><span class="p">,</span> <span class="n">cube_heaviside</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Model output for epfy and epfz is in units kg s-2.  We require</span>
<span class="sd">    units m3 s-2 for CMIP6, and so need to divide by density on</span>
<span class="sd">    each pressure level.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cube_data: :class:`iris.cube.Cube`</span>
<span class="sd">        A cube containing either y or z component of the EP flux on</span>
<span class="sd">        pressure levels.</span>
<span class="sd">    cube_heaviside: :class:`iris.cube.Cube`</span>
<span class="sd">        Heaviside data</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    : :class:`iris.cube.Cube`</span>
<span class="sd">        A cube containing the component of the EP flux scaled by</span>
<span class="sd">        density.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cube</span> <span class="o">=</span> <span class="n">zonal_apply_heaviside</span><span class="p">(</span><span class="n">cube_data</span><span class="p">,</span> <span class="n">cube_heaviside</span><span class="p">)</span>
    <span class="n">rho0</span> <span class="o">=</span> <span class="mf">1.212</span>  <span class="c1"># kg m-3</span>
    <span class="n">p0</span> <span class="o">=</span> <span class="mi">1000</span>  <span class="c1"># hPa</span>
    <span class="n">press</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="s1">&#39;pressure&#39;</span><span class="p">)</span>
    <span class="n">density</span> <span class="o">=</span> <span class="n">rho0</span> <span class="o">*</span> <span class="n">press</span> <span class="o">/</span> <span class="n">p0</span>
    <span class="n">cube</span> <span class="o">=</span> <span class="n">cube</span> <span class="o">/</span> <span class="n">density</span>
    <span class="n">cube</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="s1">&#39;m**3 s**-2&#39;</span>
    <span class="k">return</span> <span class="n">cube</span></div>


<div class="viewcode-block" id="tau_pseudo_level"><a class="viewcode-back" href="../../../mip_convert/process/processors.html#mip_convert.process.processors.tau_pseudo_level">[docs]</a><span class="k">def</span> <span class="nf">tau_pseudo_level</span><span class="p">(</span><span class="n">cube</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a cube with corrected tau coordinates (e.g. for use in</span>
<span class="sd">    `clisccp`)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cube: :class:`iris.cube.Cube`</span>
<span class="sd">        A cube with a longitude, latitude and extra dimensions.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    : :class:`iris.cube.Cube`</span>
<span class="sd">        A cube with all its 2D fields divided by the 2D mask.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tau_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mf">0.15</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mf">2.45</span><span class="p">,</span> <span class="mf">6.5</span><span class="p">,</span> <span class="mf">16.2</span><span class="p">,</span> <span class="mf">41.5</span><span class="p">,</span> <span class="mf">100.0</span><span class="p">))</span>
    <span class="n">tau1</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">1.3</span><span class="p">,</span> <span class="mf">3.6</span><span class="p">,</span> <span class="mf">9.4</span><span class="p">,</span> <span class="mf">23.0</span><span class="p">,</span> <span class="mf">60.0</span><span class="p">)</span>
    <span class="n">tau2</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">1.3</span><span class="p">,</span> <span class="mf">3.6</span><span class="p">,</span> <span class="mf">9.4</span><span class="p">,</span> <span class="mf">23.0</span><span class="p">,</span> <span class="mf">60.0</span><span class="p">,</span> <span class="mf">100000.0</span><span class="p">)</span>
    <span class="n">tau_bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">tau1</span><span class="p">,</span> <span class="n">tau2</span><span class="p">])</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
    <span class="n">stash</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="s1">&#39;STASH&#39;</span><span class="p">]</span>

    <span class="c1"># Deal with STASH codes that need special treatment.</span>
    <span class="c1"># Replace pseudo_level dimension with correct physical dimension.</span>
    <span class="k">if</span> <span class="n">stash</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;m01s02i337&#39;</span><span class="p">,</span> <span class="s1">&#39;m01s02i360&#39;</span><span class="p">,</span> <span class="s1">&#39;m01s02i450&#39;</span><span class="p">,</span> <span class="s1">&#39;m01s02i468&#39;</span><span class="p">,</span> <span class="s1">&#39;m01s02i469&#39;</span><span class="p">]:</span>
        <span class="c1"># Pseudo level</span>
        <span class="n">pseudo</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="s1">&#39;pseudo_level&#39;</span><span class="p">)</span>
        <span class="n">pseudo</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">tau_points</span>
        <span class="n">pseudo</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="s1">&#39;1&#39;</span>
        <span class="n">pseudo</span><span class="o">.</span><span class="n">standard_name</span> <span class="o">=</span> <span class="s1">&#39;atmosphere_optical_thickness_due_to_cloud&#39;</span>
        <span class="n">pseudo</span><span class="o">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="n">tau_bounds</span>

    <span class="k">return</span> <span class="n">cube</span></div>


<span class="c1"># UM/JULES tile ids. All values are lists to keep a consistent interface.</span>
<span class="n">_TILE_IDS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;broadLeafTree&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span>
    <span class="s1">&#39;broadLeafTreeDeciduous&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">101</span><span class="p">],</span>
    <span class="s1">&#39;broadLeafTreeEvergreenTropical&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">102</span><span class="p">],</span>
    <span class="s1">&#39;broadLeafTreeEvergreenTemperate&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">103</span><span class="p">],</span>
    <span class="s1">&#39;needleLeafTree&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span>
    <span class="s1">&#39;needleLeafTreeDeciduous&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">201</span><span class="p">],</span>
    <span class="s1">&#39;needleLeafTreeEvergreen&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">202</span><span class="p">],</span>
    <span class="s1">&#39;c3Grass&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span>
    <span class="s1">&#39;c3Crop&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">301</span><span class="p">],</span>
    <span class="s1">&#39;c3Pasture&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">302</span><span class="p">],</span>
    <span class="s1">&#39;c4Grass&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span>
    <span class="s1">&#39;c4Crop&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">401</span><span class="p">],</span>
    <span class="s1">&#39;c4Pasture&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">402</span><span class="p">],</span>
    <span class="s1">&#39;shrub&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span>
    <span class="s1">&#39;shrubDeciduous&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">501</span><span class="p">],</span>
    <span class="s1">&#39;shrubEvergreen&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">502</span><span class="p">],</span>
    <span class="s1">&#39;urban&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">6</span><span class="p">],</span>
    <span class="s1">&#39;water&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">7</span><span class="p">],</span>
    <span class="s1">&#39;bareSoil&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">8</span><span class="p">],</span>
    <span class="s1">&#39;ice&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">9</span><span class="p">],</span>
    <span class="s1">&#39;iceElev&#39;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">901</span><span class="p">,</span> <span class="mi">926</span><span class="p">))}</span>

<span class="c1"># Land classes made of more than on tile id the items are space separated regular expressions.</span>
<span class="c1"># the regular expressions are used in a search against the UM/JULES tile ids.</span>
<span class="n">_MULTI_TILES</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;natural&#39;</span><span class="p">:</span> <span class="s1">&#39;Tree Grass shrub&#39;</span><span class="p">,</span>
    <span class="s1">&#39;crop&#39;</span><span class="p">:</span> <span class="s1">&#39;Crop&#39;</span><span class="p">,</span>
    <span class="s1">&#39;pasture&#39;</span><span class="p">:</span> <span class="s1">&#39;Pasture&#39;</span><span class="p">,</span>
    <span class="s1">&#39;c3&#39;</span><span class="p">:</span> <span class="s1">&#39;Tree c3 shrub&#39;</span><span class="p">,</span>
    <span class="s1">&#39;c4&#39;</span><span class="p">:</span> <span class="s1">&#39;c4&#39;</span><span class="p">,</span>
    <span class="s1">&#39;grass&#39;</span><span class="p">:</span> <span class="s1">&#39;Grass&#39;</span><span class="p">,</span>
    <span class="s1">&#39;tree&#39;</span><span class="p">:</span> <span class="s1">&#39;Tree&#39;</span><span class="p">,</span>
    <span class="s1">&#39;shrub&#39;</span><span class="p">:</span> <span class="s1">&#39;shrub&#39;</span><span class="p">,</span>
    <span class="s1">&#39;broadLeafTree&#39;</span><span class="p">:</span> <span class="s1">&#39;broadLeafTree&#39;</span><span class="p">,</span>
    <span class="s1">&#39;needleLeafTree&#39;</span><span class="p">:</span> <span class="s1">&#39;needleLeafTree&#39;</span><span class="p">,</span>
    <span class="s1">&#39;broadLeafTreeDeciduous&#39;</span><span class="p">:</span> <span class="s1">&#39;broadLeafTree</span><span class="se">\\</span><span class="s1">b broadLeafTreeDeciduous&#39;</span><span class="p">,</span>
    <span class="s1">&#39;broadLeafTreeEvergreen&#39;</span><span class="p">:</span> <span class="s1">&#39;broadLeafTreeEvergreen&#39;</span><span class="p">,</span>
    <span class="s1">&#39;needleLeafTreeEvergreen&#39;</span><span class="p">:</span> <span class="s1">&#39;needleLeafTree</span><span class="se">\\</span><span class="s1">b needleLeafTreeEvergreen&#39;</span><span class="p">,</span>
    <span class="s1">&#39;residual&#39;</span><span class="p">:</span> <span class="s1">&#39;urban water ice&#39;</span><span class="p">,</span>
    <span class="s1">&#39;all&#39;</span><span class="p">:</span> <span class="s1">&#39;.+&#39;</span><span class="p">,</span>
    <span class="s1">&#39;veg&#39;</span><span class="p">:</span> <span class="s1">&#39;Tree Grass shrub Crop Pasture&#39;</span><span class="p">,</span>
<span class="p">}</span>


<div class="viewcode-block" id="tile_ids_for_class"><a class="viewcode-back" href="../../../mip_convert/process/processors.html#mip_convert.process.processors.tile_ids_for_class">[docs]</a><span class="k">def</span> <span class="nf">tile_ids_for_class</span><span class="p">(</span><span class="n">land_class</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a list of tile ids for the land_class</span>

<span class="sd">    Some land classes, such as &#39;tree&#39; are made of more than</span>
<span class="sd">    one tile.  This function will do the lookup of land classes</span>
<span class="sd">    to tile ids.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    land_class: str</span>
<span class="sd">               The name of the land class find tile ids for.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list of int</span>
<span class="sd">              The tile ids for the land_class.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">              If the land_class is not recognized.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_values_for_re</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">re_str</span><span class="p">):</span>
        <span class="n">ids</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">mapping</span><span class="o">.</span><span class="n">items</span><span class="p">())</span> <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">re_str</span><span class="p">,</span> <span class="n">key</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ids</span>

    <span class="k">def</span> <span class="nf">_flatten</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">seq</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">land_class</span> <span class="ow">in</span> <span class="n">_MULTI_TILES</span><span class="p">:</span>
        <span class="n">tile_regex</span> <span class="o">=</span> <span class="n">_MULTI_TILES</span><span class="p">[</span><span class="n">land_class</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
        <span class="n">agg_ids</span> <span class="o">=</span> <span class="p">(</span><span class="n">_values_for_re</span><span class="p">(</span><span class="n">_TILE_IDS</span><span class="p">,</span> <span class="n">tile</span><span class="p">)</span> <span class="k">for</span> <span class="n">tile</span> <span class="ow">in</span> <span class="n">tile_regex</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">_flatten</span><span class="p">(</span><span class="n">agg_ids</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">_TILE_IDS</span><span class="p">[</span><span class="n">land_class</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">result</span></div>


<span class="k">def</span> <span class="nf">_pseudo_constraint</span><span class="p">(</span><span class="n">land_class</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return an iris constraint for pseudo levels for this land_class.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">tile_ids</span> <span class="o">=</span> <span class="n">tile_ids_for_class</span><span class="p">(</span><span class="n">land_class</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">land_class</span><span class="p">,</span> <span class="s2">&quot;is not an available land class&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">iris</span><span class="o">.</span><span class="n">Constraint</span><span class="p">(</span><span class="n">pseudo_level</span><span class="o">=</span><span class="n">tile_ids</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_collapse_pseudo</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="n">aggregator</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns cube collased along pseudo_level using aggregator</span>
<span class="sd">    with kwargs.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">cube</span>
    <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="s1">&#39;Collapsing.*pseudo_level.*&#39;</span><span class="p">,</span> <span class="ne">UserWarning</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="s1">&#39;pseudo_level&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">collapsed</span><span class="p">([</span><span class="s1">&#39;pseudo_level&#39;</span><span class="p">],</span> <span class="n">aggregator</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>


<div class="viewcode-block" id="land_class_mean"><a class="viewcode-back" href="../../../mip_convert/process/processors.html#mip_convert.process.processors.land_class_mean">[docs]</a><span class="k">def</span> <span class="nf">land_class_mean</span><span class="p">(</span><span class="n">variable_cube</span><span class="p">,</span> <span class="n">tile_cube</span><span class="p">,</span> <span class="n">land_class</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the cube of the mean variable_cube over a land class.</span>

<span class="sd">    This can be used when the MIP request is for</span>
<span class="sd">    cell_methods: &#39;area: mean where land&#39;.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    variable_cube: :class:`iris.cube.Cube`</span>
<span class="sd">                  the cube containing the input variable on the JULES tiles.</span>

<span class="sd">    tile_cube: :class:`iris.cube.Cube`</span>
<span class="sd">                  the fraction of land covered by each JULES tile.</span>

<span class="sd">    land_class: str</span>
<span class="sd">                  the vegetation class to average over.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    : :class:`iris.cube.Cube`</span>
<span class="sd">                  cube of the mean of the variable over land_class.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pseudo_constraint</span> <span class="o">=</span> <span class="n">_pseudo_constraint</span><span class="p">(</span><span class="n">land_class</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">variable_cube</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">pseudo_constraint</span><span class="p">)</span>
    <span class="n">tile_cube</span> <span class="o">=</span> <span class="n">tile_cube</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">pseudo_constraint</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">_collapse_pseudo</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">MEAN</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">tile_cube</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="land_class_area"><a class="viewcode-back" href="../../../mip_convert/process/processors.html#mip_convert.process.processors.land_class_area">[docs]</a><span class="k">def</span> <span class="nf">land_class_area</span><span class="p">(</span><span class="n">tile_cube</span><span class="p">,</span> <span class="n">land_frac_cube</span><span class="p">,</span> <span class="n">land_class</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the cube of the area covered by the chosen land class.</span>

<span class="sd">    This can be used when the MIP requests cell_methods: &#39;area:mean&#39;.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tile_cube: :class:`iris.cube.Cube`</span>
<span class="sd">                  the fraction of land covered by each JULES tile.</span>

<span class="sd">    land_frac_cube:  :class:`iris.cube.Cube`</span>
<span class="sd">                  the fraction of a gridcell covered by land.</span>

<span class="sd">    land_class: str</span>
<span class="sd">                  the land class to sum area over.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    : :class:`iris.cube.Cube`</span>
<span class="sd">                  the cube with the mean area of land_class.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">pseudo_constraint</span> <span class="o">=</span> <span class="n">_pseudo_constraint</span><span class="p">(</span><span class="n">land_class</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">tile_cube</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">pseudo_constraint</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">_collapse_pseudo</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">SUM</span><span class="p">)</span>

    <span class="c1">#  turn the land only quantity into area of grid cell:</span>
    <span class="n">result</span> <span class="o">*=</span> <span class="n">land_frac_cube</span><span class="o">.</span><span class="n">data</span> <span class="o">*</span> <span class="mf">100.0</span>
    <span class="n">result</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="s2">&quot;%&quot;</span>
    <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="snc_calc"><a class="viewcode-back" href="../../../mip_convert/process/processors.html#mip_convert.process.processors.snc_calc">[docs]</a><span class="k">def</span> <span class="nf">snc_calc</span><span class="p">(</span><span class="n">variable_cube</span><span class="p">,</span> <span class="n">tile_fraction_cube</span><span class="p">,</span> <span class="n">land_fraction_cube</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sum of land frac over tiles with snow for the land portion of the grid cell</span>
<span class="sd">    It is assumed if there is less than 0.1 kg/m2 (0.1 mm SWE) of snow on the</span>
<span class="sd">    ground there is no snow otherwise we have snow in the Sahara. This threshold</span>
<span class="sd">    is a rather arbitrary value.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    variable_cube: :class:`iris.cube.Cube`</span>
<span class="sd">        the cube containing the snow amount on JULES tiles (kg/m2).</span>

<span class="sd">    tile_fraction_cube: :class:`iris.cube.Cube`</span>
<span class="sd">        the fraction of land covered by each JULES tile.</span>

<span class="sd">    land_fraction_cube: :class:`iris.cube.Cube`</span>
<span class="sd">        the proportion of land in the grid cell</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    : :class:`iris.cube.Cube`</span>
<span class="sd">        A cube containing the snow fraction of each grid cell as a percentage</span>
<span class="sd">        of the land area in the grid cell.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">SWE_MIN</span> <span class="o">=</span> <span class="mf">0.1</span>
    <span class="n">variable_cube</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">variable_cube</span><span class="o">.</span><span class="n">data</span> <span class="o">&lt;=</span> <span class="n">SWE_MIN</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">variable_cube</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">variable_cube</span><span class="o">.</span><span class="n">data</span> <span class="o">&gt;</span> <span class="n">SWE_MIN</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">variable_cube</span> <span class="o">=</span> <span class="n">variable_cube</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">variable_cube</span><span class="o">.</span><span class="n">data</span> <span class="o">*</span> <span class="n">tile_fraction_cube</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
    <span class="n">cube</span> <span class="o">=</span> <span class="n">variable_cube</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="s1">&#39;pseudo_level&#39;</span><span class="p">,</span> <span class="n">SUM</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">*</span> <span class="n">land_fraction_cube</span>
    <span class="k">return</span> <span class="n">cube</span></div>


<div class="viewcode-block" id="areacella"><a class="viewcode-back" href="../../../mip_convert/process/processors.html#mip_convert.process.processors.areacella">[docs]</a><span class="k">def</span> <span class="nf">areacella</span><span class="p">(</span><span class="n">cube</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    From a cube containing any data on a model&#39;s standard grid, the area of</span>
<span class="sd">    each cell is calculated and returned in an Iris cube.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cube: :class:`iris.cube.Cube`</span>
<span class="sd">        A cube containing data on the standard grid for that model.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    : :class:`iris.cube.Cube`</span>
<span class="sd">        A cube containing the area of each cell in the input cube</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If the cube is not a 2 dimensional latitude-longitude</span>
<span class="sd">        cube.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">_lat_lon_dim_coords</span><span class="p">(</span><span class="n">cube</span><span class="p">):</span>
        <span class="n">coord_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;latitude&#39;</span><span class="p">,</span> <span class="s1">&#39;longitude&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">icoord</span><span class="p">,</span> <span class="n">coord</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cube</span><span class="o">.</span><span class="n">coords</span><span class="p">(</span><span class="n">dim_coords</span><span class="o">=</span><span class="kc">True</span><span class="p">)):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">coord_names</span><span class="p">[</span><span class="n">icoord</span><span class="p">]</span> <span class="ow">in</span> <span class="n">coord</span><span class="o">.</span><span class="n">name</span><span class="p">():</span>
                <span class="n">message</span> <span class="o">=</span> <span class="s1">&#39;areacella assumes a 2D cube ordered latitude, longitude&#39;</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

    <span class="n">_lat_lon_dim_coords</span><span class="p">(</span><span class="n">cube</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">coord_name</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;latitude&#39;</span><span class="p">,</span> <span class="s1">&#39;longitude&#39;</span><span class="p">]:</span>
        <span class="n">guess_bounds_if_needed</span><span class="p">(</span><span class="n">cube</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="n">coord_name</span><span class="p">))</span>

    <span class="n">cell_areas</span> <span class="o">=</span> <span class="n">area_weights</span><span class="p">(</span><span class="n">cube</span><span class="p">)</span>
    <span class="n">cell_area_cube</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">cube</span><span class="o">.</span><span class="n">Cube</span><span class="p">(</span><span class="n">cell_areas</span><span class="p">,</span>
                                    <span class="n">var_name</span><span class="o">=</span><span class="s1">&#39;cell_area&#39;</span><span class="p">,</span>
                                    <span class="n">dim_coords_and_dims</span><span class="o">=</span><span class="p">[(</span><span class="n">cube</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="s1">&#39;latitude&#39;</span><span class="p">),</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">cube</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="s1">&#39;longitude&#39;</span><span class="p">),</span> <span class="mi">1</span><span class="p">)],</span>
                                    <span class="n">units</span><span class="o">=</span><span class="n">Unit</span><span class="p">(</span><span class="s1">&#39;m2&#39;</span><span class="p">)</span>
                                    <span class="p">)</span>
    <span class="k">return</span> <span class="n">cell_area_cube</span></div>


<div class="viewcode-block" id="fix_packing_division"><a class="viewcode-back" href="../../../mip_convert/process/processors.html#mip_convert.process.processors.fix_packing_division">[docs]</a><span class="k">def</span> <span class="nf">fix_packing_division</span><span class="p">(</span><span class="n">numerator</span><span class="p">,</span> <span class="n">denominator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    It fixes the zeroes introduced by the loss of precision caused by</span>
<span class="sd">    packing. It performs a division of 2 cubes of the same shape,</span>
<span class="sd">    and replaces the zeroes with a new value (0.5*minimum).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    numerator: :class:`iris.cube.Cube`</span>
<span class="sd">        A cube containing the numerator of the division.</span>
<span class="sd">    denominator: :class:`iris.cube.Cube`</span>
<span class="sd">        A cube containing the denominator of the division.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    : :class:`iris.cube.Cube`</span>
<span class="sd">        A cube the cube with the division, corrected.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cube</span> <span class="o">=</span> <span class="n">numerator</span> <span class="o">/</span> <span class="n">denominator</span>
    <span class="n">cube</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">cube</span><span class="o">.</span><span class="n">data</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">cube</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">cube</span><span class="o">.</span><span class="n">data</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">cube</span></div>


<span class="k">def</span> <span class="nf">_z_axis</span><span class="p">(</span><span class="n">cube</span><span class="p">):</span>
    <span class="n">z_coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">coord</span> <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">cube</span><span class="o">.</span><span class="n">coords</span><span class="p">()</span> <span class="k">if</span> <span class="n">guess_coord_axis</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;Z&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">z_coords</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cube should have exactly one &#39;Z&#39; axis&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">z_coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>


<div class="viewcode-block" id="level_sum"><a class="viewcode-back" href="../../../mip_convert/process/processors.html#mip_convert.process.processors.level_sum">[docs]</a><span class="k">def</span> <span class="nf">level_sum</span><span class="p">(</span><span class="n">cube</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the sum over vertical levels of a cube.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cube: :class:`iris.cube.Cube`</span>
<span class="sd">        A cube with vertical levels.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    : :class:`iris.cube.Cube`</span>
<span class="sd">        A cube with the data in the input cube summed over level.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If the input cube does not have exactly one vertical coordinate</span>
<span class="sd">        to sum over.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">cube</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="n">_z_axis</span><span class="p">(</span><span class="n">cube</span><span class="p">),</span> <span class="n">SUM</span><span class="p">)</span></div>


<div class="viewcode-block" id="sum_over_upper_100m"><a class="viewcode-back" href="../../../mip_convert/process/processors.html#mip_convert.process.processors.sum_over_upper_100m">[docs]</a><span class="k">def</span> <span class="nf">sum_over_upper_100m</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="n">thickness</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the sum over the upper 100m of a cube.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cube: :class:`iris.cube.Cube`</span>
<span class="sd">        A cube with vertical levels.</span>
<span class="sd">    thickness: :class:`iris.cube.Cube`</span>
<span class="sd">        A cube the same shape as ``cube`` containing thickness of ocean</span>
<span class="sd">        levels.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    : :class:`iris.cube.Cube`</span>
<span class="sd">        A cube with the data in ``cube`` summed over the upper 100m.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If the input cube does not have exactly one vertical coordinate</span>
<span class="sd">        to sum over.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Find the cell containing 100m.</span>
    <span class="n">depth_coord</span> <span class="o">=</span> <span class="n">_z_axis</span><span class="p">(</span><span class="n">thickness</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">count</span><span class="p">,</span> <span class="n">bounds</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">depth_coord</span><span class="o">.</span><span class="n">bounds</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">100.</span><span class="p">:</span>
            <span class="n">index1</span> <span class="o">=</span> <span class="n">count</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">index2</span> <span class="o">=</span> <span class="n">count</span>
            <span class="k">break</span>

    <span class="c1"># in this context, &quot;below&quot; means &quot;depth less than 100 m&quot;, i.e. &quot;above the 100m layer&quot;</span>
    <span class="n">depth_below_100m</span> <span class="o">=</span> <span class="n">depth_coord</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">index1</span><span class="p">]</span>
    <span class="n">depth_around_100m</span> <span class="o">=</span> <span class="n">depth_coord</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">index2</span><span class="p">]</span>

    <span class="n">constraint_below_100m</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">Constraint</span><span class="p">(</span>
        <span class="n">depth</span><span class="o">=</span><span class="k">lambda</span> <span class="n">cell</span><span class="p">:</span> <span class="n">cell</span> <span class="o">&lt;</span> <span class="n">depth_below_100m</span><span class="p">)</span>
    <span class="n">constraint_around_100m</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">Constraint</span><span class="p">(</span><span class="n">depth</span><span class="o">=</span><span class="n">depth_around_100m</span><span class="p">)</span>

    <span class="n">cube_below_100m</span> <span class="o">=</span> <span class="n">level_sum</span><span class="p">(</span><span class="n">cube</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">constraint_below_100m</span><span class="p">))</span>
    <span class="n">cube_around_100m</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">constraint_around_100m</span><span class="p">)</span>
    <span class="n">factor</span> <span class="o">=</span> <span class="p">(</span><span class="mf">100.</span> <span class="o">-</span> <span class="n">depth_below_100m</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">depth_around_100m</span> <span class="o">-</span> <span class="n">depth_below_100m</span><span class="p">)</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">cube_below_100m</span> <span class="o">+</span> <span class="p">(</span><span class="n">factor</span> <span class="o">*</span> <span class="n">cube_around_100m</span><span class="p">)</span>
    <span class="c1"># shallow seas contain masked data at the 100 meters level, and the sum of masked and unmasked data is masked</span>
    <span class="c1"># so below we fix that to unmask the integral</span>
    <span class="n">result</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">cube_below_100m</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">cube_around_100m</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">mask</span>
    <span class="n">coord_at_100m</span> <span class="o">=</span> <span class="n">depth_coord</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">points</span><span class="o">=</span><span class="p">[</span><span class="mf">50.</span><span class="p">],</span> <span class="n">bounds</span><span class="o">=</span><span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">100.</span><span class="p">])</span>

    <span class="n">result</span><span class="o">.</span><span class="n">add_aux_coord</span><span class="p">(</span><span class="n">coord_at_100m</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="level_mean"><a class="viewcode-back" href="../../../mip_convert/process/processors.html#mip_convert.process.processors.level_mean">[docs]</a><span class="k">def</span> <span class="nf">level_mean</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="n">thick</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a mean over the vertical levels of cube weighted by thick</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cube: :class:`iris.cube.Cube`</span>
<span class="sd">        A cube with a depth vertical axis</span>
<span class="sd">    thick: :class:`iris.cube.Cube`</span>
<span class="sd">        A cube the same shape as cube containing thickness</span>
<span class="sd">        of ocean levels</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    : :class:`iris.cube.Cube`</span>
<span class="sd">        A cube collapsed over the depth axis</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">cube</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="n">_z_axis</span><span class="p">(</span><span class="n">cube</span><span class="p">),</span> <span class="n">MEAN</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">thick</span><span class="o">.</span><span class="n">data</span><span class="p">)</span></div>


<div class="viewcode-block" id="vortmean"><a class="viewcode-back" href="../../../mip_convert/process/processors.html#mip_convert.process.processors.vortmean">[docs]</a><span class="k">def</span> <span class="nf">vortmean</span><span class="p">(</span><span class="n">cube</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate the CMIP6 vortmean variable, the mean vorticity over the</span>
<span class="sd">    850-600 hPa layer.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cube: :class:`iris.cube.Cube`</span>
<span class="sd">        A cube containing data between 600 and 850 hPa.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    : :class:`iris.cube.Cube`</span>
<span class="sd">        A cube containing the mean over pressure of the input cube</span>
<span class="sd">        between 600 and 850 hPa.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">_z_axis</span><span class="p">(</span><span class="n">cube</span><span class="p">)</span>
    <span class="n">z</span><span class="o">.</span><span class="n">convert_units</span><span class="p">(</span><span class="s1">&#39;hPa&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="p">[</span><span class="mf">600.</span><span class="p">,</span> <span class="mi">700</span><span class="p">,</span> <span class="mi">850</span><span class="p">]):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;CMIP6 vortmean should be derived from 600, 700, 850 hPa levels&#39;</span><span class="p">)</span>

    <span class="n">vortmean_cube</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">MEAN</span><span class="p">)</span>
    <span class="c1"># Iris sets the pressure to be the mean, which is typically 725</span>
    <span class="c1"># hPa, but the data request asks for a value at 700 hPa and so</span>
    <span class="c1"># change to this. CMOR will set the bounds appropriately.</span>
    <span class="n">plev_coord</span> <span class="o">=</span> <span class="n">vortmean_cube</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="s1">&#39;pressure&#39;</span><span class="p">)</span>
    <span class="n">plev_coord</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">700.</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">vortmean_cube</span></div>


<div class="viewcode-block" id="mask_zeros"><a class="viewcode-back" href="../../../mip_convert/process/processors.html#mip_convert.process.processors.mask_zeros">[docs]</a><span class="k">def</span> <span class="nf">mask_zeros</span><span class="p">(</span><span class="n">cube</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns cube with the data set to masked values where the value is 0.</span>

<span class="sd">    If the cube data is a numpy array containing no zeros then the cube is</span>
<span class="sd">    unchanged on output.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cube: :class:`iris.cube.Cube`</span>
<span class="sd">        A cube containing data that may have zero values.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    : :class:`iris.cube.Cube`</span>
<span class="sd">        A cube with zeros set to masked values.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ma_data</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">)</span>
    <span class="n">odata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_equal</span><span class="p">(</span><span class="n">ma_data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">is_masked</span><span class="p">(</span><span class="n">odata</span><span class="p">):</span>
        <span class="n">cube</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">odata</span>
    <span class="k">return</span> <span class="n">cube</span></div>


<div class="viewcode-block" id="mask_using_cube"><a class="viewcode-back" href="../../../mip_convert/process/processors.html#mip_convert.process.processors.mask_using_cube">[docs]</a><span class="k">def</span> <span class="nf">mask_using_cube</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="n">cube_for_mask</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the ``cube`` masked where the data in ``cube_for_mask`` is</span>
<span class="sd">    less than or equal to zero.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cube: :class:`iris.cube.Cube`</span>
<span class="sd">        The cube to be masked.</span>
<span class="sd">    cube_for_mask: :class:`iris.cube.Cube`</span>
<span class="sd">        The cube containing data that may have values less than or equal</span>
<span class="sd">        to zero.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    : :class:`iris.cube.Cube`</span>
<span class="sd">        The cube masked where the data in ``cube_for_mask`` is less than</span>
<span class="sd">        or equal to zero.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cube</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_where</span><span class="p">(</span><span class="n">cube_for_mask</span><span class="o">.</span><span class="n">data</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cube</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cube</span></div>


<div class="viewcode-block" id="correct_evaporation"><a class="viewcode-back" href="../../../mip_convert/process/processors.html#mip_convert.process.processors.correct_evaporation">[docs]</a><span class="k">def</span> <span class="nf">correct_evaporation</span><span class="p">(</span><span class="n">cube_evs</span><span class="p">,</span> <span class="n">cube_res</span><span class="p">,</span> <span class="n">cube_area</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return corrected evs data using the residual (i.e. differences</span>
<span class="sd">    between the total fresh water flux and its reconstruction).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cube_evs: :class:`iris.cube.Cube`</span>
<span class="sd">        A cube containing evs original data</span>
<span class="sd">    cube_res: :class:`iris.cube.Cube`</span>
<span class="sd">        A cube containing the residual</span>
<span class="sd">        &quot;empmr - (evs - (icb - isf + rain + snow + river + ice))&quot;</span>
<span class="sd">        i.e. cube_res = error on evs + closed sea contribution</span>
<span class="sd">    cube_area: :class:`iris.cube.Cube`</span>
<span class="sd">        A cube containing cell area data</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    : :class:`iris.cube.Cube`</span>
<span class="sd">        A cube for the corrected evaporation over the ocean evs.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># 1.1 get NEMO surface mask</span>
    <span class="n">mask2d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_invalid</span><span class="p">(</span><span class="n">cube_area</span><span class="o">.</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

    <span class="c1"># compute closed seas mask</span>
    <span class="n">mask_closed_seas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">mask2d</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="c1"># 1.2 select the grid (closed sea index hard coded)</span>
    <span class="n">EORCA1_SHAPE</span> <span class="o">=</span> <span class="p">(</span><span class="mi">330</span><span class="p">,</span> <span class="mi">360</span><span class="p">)</span>
    <span class="n">EORCA025_SHAPE</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1205</span><span class="p">,</span> <span class="mi">1440</span><span class="p">)</span>

    <span class="c1"># definition of closed lakes used in NEMO GO6 when lake missing &#39;block slice&#39; is used</span>
    <span class="k">if</span> <span class="n">mask2d</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">EORCA1_SHAPE</span><span class="p">:</span>
        <span class="n">closed_seas_locations</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;caspian&#39;</span><span class="p">:</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="mi">238</span><span class="p">,</span> <span class="mi">272</span><span class="p">),</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">331</span><span class="p">,</span> <span class="mi">346</span><span class="p">)),</span>
            <span class="s1">&#39;victoria&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s1">&#39;greatlake&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s1">&#39;asov&#39;</span><span class="p">:</span> <span class="kc">None</span>
        <span class="p">}</span>
    <span class="k">elif</span> <span class="n">mask2d</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">EORCA025_SHAPE</span><span class="p">:</span>
        <span class="n">closed_seas_locations</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;caspian&#39;</span><span class="p">:</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="mi">834</span><span class="p">,</span> <span class="mi">994</span><span class="p">),</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">1324</span><span class="p">,</span> <span class="mi">1423</span><span class="p">)),</span>
            <span class="s1">&#39;victoria&#39;</span><span class="p">:</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="mi">667</span><span class="p">,</span> <span class="mi">690</span><span class="p">),</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">1267</span><span class="p">,</span> <span class="mi">1300</span><span class="p">)),</span>
            <span class="s1">&#39;greatlake&#39;</span><span class="p">:</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="mi">865</span><span class="p">,</span> <span class="mi">930</span><span class="p">),</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">770</span><span class="p">,</span> <span class="mi">850</span><span class="p">)),</span>
            <span class="s1">&#39;asov&#39;</span><span class="p">:</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="mi">906</span><span class="p">,</span> <span class="mi">933</span><span class="p">),</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">1282</span><span class="p">,</span> <span class="mi">1304</span><span class="p">))</span>
        <span class="p">}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">configuration</span> <span class="o">=</span> <span class="s1">&#39;(eORCA1 : &quot;</span><span class="si">{0}</span><span class="s1">&quot; , eORCA025 : &quot;</span><span class="si">{1}</span><span class="s1">&quot; )&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">EORCA1_SHAPE</span><span class="p">,</span> <span class="n">EORCA025_SHAPE</span><span class="p">)</span>
        <span class="n">message</span> <span class="o">=</span> <span class="s1">&#39;Dimension &quot;</span><span class="si">{0}</span><span class="s1">&quot; is not known or not tested configuration &quot;</span><span class="si">{1}</span><span class="s1">&quot;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mask2d</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">configuration</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

    <span class="c1"># mask closed seas</span>
    <span class="k">for</span> <span class="n">closed_seas_slices</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">closed_seas_locations</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
        <span class="k">if</span> <span class="n">closed_seas_slices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mask_closed_seas</span><span class="p">[</span><span class="n">closed_seas_slices</span><span class="p">]</span> <span class="o">=</span> <span class="n">mask2d</span><span class="p">[</span><span class="n">closed_seas_slices</span><span class="p">]</span>

    <span class="c1"># 1.3 compute no closed sea mask</span>
    <span class="n">mask_no_closed_seas</span> <span class="o">=</span> <span class="n">mask2d</span> <span class="o">-</span> <span class="n">mask_closed_seas</span>

    <span class="c1"># 2 compute total loss/gain over closed sea (main ocean is not defined yet at this stage)</span>
    <span class="c1"># closed seas contribution is the residual of empmr computed from the individual term and the total.</span>
    <span class="n">cube_closed_seas</span> <span class="o">=</span> <span class="n">cube_res</span> <span class="o">*</span> <span class="n">mask_closed_seas</span>

    <span class="c1"># 3.1 compute total area of closed seas and main ocean</span>
    <span class="n">area_closed_seas</span> <span class="o">=</span> <span class="p">(</span><span class="n">cube_area</span> <span class="o">*</span> <span class="n">mask_closed_seas</span><span class="p">)</span><span class="o">.</span><span class="n">collapsed</span><span class="p">((</span><span class="s1">&#39;latitude&#39;</span><span class="p">,</span> <span class="s1">&#39;longitude&#39;</span><span class="p">),</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">SUM</span><span class="p">)</span><span class="o">.</span><span class="n">data</span>
    <span class="n">area_no_closed_seas</span> <span class="o">=</span> <span class="p">(</span><span class="n">cube_area</span> <span class="o">*</span> <span class="n">mask_no_closed_seas</span><span class="p">)</span><span class="o">.</span><span class="n">collapsed</span><span class="p">((</span><span class="s1">&#39;latitude&#39;</span><span class="p">,</span> <span class="s1">&#39;longitude&#39;</span><span class="p">),</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">SUM</span><span class="p">)</span><span class="o">.</span><span class="n">data</span>

    <span class="c1"># 3.2 compute closed seas contribution</span>
    <span class="c1"># sanity check on dimension</span>
    <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cube_closed_seas</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ndim</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="c1"># unknown case</span>
        <span class="n">message</span> <span class="o">=</span> <span class="s1">&#39;Number of dimensions in cube_closed_seas (&quot;</span><span class="si">{}</span><span class="s1">&quot;) not supported. Cube: &quot;</span><span class="si">{}</span><span class="s1">&quot;&#39;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">message</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ndim</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">cube_closed_seas</span><span class="p">)))</span>

    <span class="c1"># for alternative</span>
    <span class="n">no_closed_seas_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_no_closed_seas</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">cube_area_masked</span> <span class="o">=</span> <span class="n">cube_area</span><span class="o">.</span><span class="n">data</span> <span class="o">*</span> <span class="n">mask_closed_seas</span>

    <span class="n">num_times</span> <span class="o">=</span> <span class="n">cube_closed_seas</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_times</span><span class="p">):</span>
        <span class="c1"># compute total closed sea contribution</span>
        <span class="n">total_closed_seas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">cube_closed_seas</span><span class="o">.</span><span class="n">data</span> <span class="o">*</span> <span class="n">cube_area_masked</span><span class="p">)</span>

        <span class="c1"># compute closed seas contribution over the ocean (no closed sea) spread closed seas contribution</span>
        <span class="c1"># evenly over the main ocean. Only overwrite grid cells where the data is to be masked (no_closed_seas_inds).</span>
        <span class="n">seas_contribution</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span> <span class="n">total_closed_seas</span> <span class="o">/</span> <span class="n">area_no_closed_seas</span><span class="p">)</span>
        <span class="n">cube_closed_seas</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">no_closed_seas_inds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">no_closed_seas_inds</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">seas_contribution</span>

    <span class="c1"># 4 compute and retrun corrected evs</span>
    <span class="k">return</span> <span class="n">cube_evs</span> <span class="o">+</span> <span class="n">cube_res</span> <span class="o">-</span> <span class="n">cube_closed_seas</span></div>


<div class="viewcode-block" id="div_by_area"><a class="viewcode-back" href="../../../mip_convert/process/processors.html#mip_convert.process.processors.div_by_area">[docs]</a><span class="k">def</span> <span class="nf">div_by_area</span><span class="p">(</span><span class="n">incube</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Divide the input cube with area of each gridcell</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    incube: :class:`iris.cube.Cube`</span>
<span class="sd">        Input cube 3-D/ 4-D.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    : :class:`iris.cube.Cube`</span>
<span class="sd">        Cube divided by area (m-2)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Generate grid box areas - single time and level</span>
    <span class="n">grid_areas</span> <span class="o">=</span> <span class="n">areacella</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">incube</span><span class="o">.</span><span class="n">slices</span><span class="p">([</span><span class="s1">&#39;latitude&#39;</span><span class="p">,</span> <span class="s1">&#39;longitude&#39;</span><span class="p">])))</span>
    <span class="n">incube</span><span class="o">.</span><span class="n">data</span> <span class="o">/=</span> <span class="n">grid_areas</span><span class="o">.</span><span class="n">data</span>
    <span class="k">return</span> <span class="n">incube</span></div>


<div class="viewcode-block" id="mask_copy"><a class="viewcode-back" href="../../../mip_convert/process/processors.html#mip_convert.process.processors.mask_copy">[docs]</a><span class="k">def</span> <span class="nf">mask_copy</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="n">cube_mask</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Overwrite the mask of a cube.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cube : :class:`iris.cube.Cube`</span>
<span class="sd">        A cube containing data to be masked.</span>
<span class="sd">    cube_mask : :class:`iris.cube.Cube`</span>
<span class="sd">        A cube containing the mask to be applied (1 where masked, else 0).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    :class:`iris.cube.Cube`</span>
<span class="sd">        `cube` with data masked by `cube_mask`.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If one of the following conditions is met:</span>

<span class="sd">        * `cube_mask` contains a &quot;time&quot; coordinate</span>
<span class="sd">        * `cube` &amp; `cube_mask` have different shapes (except the time dimension)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Coordinate names</span>
    <span class="n">coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">name</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">cube</span><span class="o">.</span><span class="n">coords</span><span class="p">()]</span>
    <span class="n">mask_coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">name</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">cube_mask</span><span class="o">.</span><span class="n">coords</span><span class="p">()]</span>

    <span class="c1"># Check that mask does not have a time coordinate</span>
    <span class="k">if</span> <span class="s1">&#39;time&#39;</span> <span class="ow">in</span> <span class="n">mask_coords</span><span class="p">:</span>
        <span class="n">message</span> <span class="o">=</span> <span class="s1">&#39;Source mask cube must not have a time coordinate (found &quot;</span><span class="si">{}</span><span class="s1">&quot;)&#39;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">message</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mask_coords</span><span class="p">))</span>

    <span class="c1"># Check that cube and mask are consistent in shape, ignoring time dimension</span>
    <span class="k">if</span> <span class="s1">&#39;time&#39;</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">:</span>
        <span class="n">dim_t</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">coord_dims</span><span class="p">(</span><span class="n">cube</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">cube_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">j</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cube</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">dim_t</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cube_shape</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">shape</span>

    <span class="k">if</span> <span class="n">cube_shape</span> <span class="o">!=</span> <span class="n">cube_mask</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="n">message</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;The cube used as the mask source must have the same shape as the cube to be masked, &#39;</span>
                   <span class="s1">&#39;ignoring the time dimension: </span><span class="se">\n\t</span><span class="s1">Mask source: </span><span class="si">{}</span><span class="se">\n\t</span><span class="s1">Cube to be masked: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">message</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cube_mask</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">(),</span> <span class="n">cube</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()))</span>

    <span class="c1"># Convert cube data to a MaskedArray if necessary</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cube</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">):</span>
        <span class="n">cube</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cube</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># Expand mask if necessary (required for numpy 1.15)</span>
    <span class="k">if</span> <span class="n">cube</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">nomask</span><span class="p">:</span>
        <span class="n">cube</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">cube</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

    <span class="c1"># Broadcast mask over time and apply to cube to be masked</span>
    <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">cube</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span> <span class="n">cube_mask</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">cube</span></div>


<div class="viewcode-block" id="sum_2d_and_3d"><a class="viewcode-back" href="../../../mip_convert/process/processors.html#mip_convert.process.processors.sum_2d_and_3d">[docs]</a><span class="k">def</span> <span class="nf">sum_2d_and_3d</span><span class="p">(</span><span class="n">cube2d</span><span class="p">,</span> <span class="n">cube3d</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adds a 2D cube to the 1st level of a 3D cube (excluding time dimension).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cube2d: :class:`iris.cube.Cube`</span>
<span class="sd">        A cube with 2 dimensions (+ time)</span>
<span class="sd">        The shape must be the same as the shape of 1 level of cube3d.</span>
<span class="sd">    cube3d: :class:`iris.cube.Cube`</span>
<span class="sd">        A cube with 3 dimensions (+ time)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    : :class:`iris.cube.Cube`</span>
<span class="sd">        A cube the same size as cube3d with cube2d added to the first level</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">cube3d</span><span class="o">.</span><span class="n">data</span>
    <span class="n">data</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">cube2d</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
    <span class="n">cube3d</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
    <span class="k">return</span> <span class="n">cube3d</span></div>


<div class="viewcode-block" id="eos_insitu"><a class="viewcode-back" href="../../../mip_convert/process/processors.html#mip_convert.process.processors.eos_insitu">[docs]</a><span class="k">def</span> <span class="nf">eos_insitu</span><span class="p">(</span><span class="n">zt</span><span class="p">,</span> <span class="n">zs</span><span class="p">,</span> <span class="n">zh</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the in-situ density of seawater using a modified version of the</span>
<span class="sd">    Jackett and McDougall (1995) [eos_insitu_1]_ equation of state.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    zt: :class:`numpy.ndarray`</span>
<span class="sd">        Potential temperature (degrees Celsius)</span>
<span class="sd">    zs: :class:`numpy.ndarray`</span>
<span class="sd">        Practical salinity (PSU)</span>
<span class="sd">    zh: :class:`numpy.ndarray`</span>
<span class="sd">        Depth (m), approximating pressure (dbar)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rho: :class:`numpy.ndarray`</span>
<span class="sd">        In-situ density (kg/m3)</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Rounding is necessary to reproduce the following worked examples:</span>

<span class="sd">    * From the NEMO `eos_insitu` docstring</span>

<span class="sd">        &gt;&gt;&gt; round(eos_insitu(40., 40., 10000.), 5)</span>
<span class="sd">        1060.93299</span>

<span class="sd">    * From Jackett and McDougall (1995) [eos_insitu_1]_</span>

<span class="sd">        &gt;&gt;&gt; round(eos_insitu(3., 35.5, 3000.), 3)</span>
<span class="sd">        1041.833</span>


<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This is a Python implementation of the NEMO 3.6 alpha routine `eos_insitu`_</span>
<span class="sd">    that has been refactored to reduce the number of 3D working arrays.</span>

<span class="sd">    Note that the original Fortran routine returns the in-situ density</span>
<span class="sd">    anomaly `prd` instead of `rho`.</span>

<span class="sd">    .. _eos_insitu: http://forge.ipsl.jussieu.fr/nemo/browser/trunk/NEMOGCM/</span>
<span class="sd">                    NEMO/OPA_SRC/TRA/eosbn2.F90?rev=4624#L76</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [eos_insitu_1]</span>
<span class="sd">        Jackett, D.R. and Mcdougall, T.J., 1995. Minimal adjustment of</span>
<span class="sd">        hydrographic profiles to achieve static</span>
<span class="sd">        stability. Journal of Atmospheric and Oceanic Technology,</span>
<span class="sd">        12(2), pp.381-389.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">zt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">zt</span><span class="p">)</span>
    <span class="n">zs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">zs</span><span class="p">)</span>
    <span class="n">zh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">zh</span><span class="p">)</span>

    <span class="c1"># zb = zbw + ze * zs</span>
    <span class="n">zwrk</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">3.508914e-8</span> <span class="o">*</span> <span class="n">zt</span> <span class="o">-</span> <span class="mf">1.248266e-8</span><span class="p">)</span> <span class="o">*</span> <span class="n">zt</span> <span class="o">-</span> <span class="mf">2.595994e-6</span>   <span class="c1"># ze</span>
    <span class="n">zwrk</span> <span class="o">*=</span> <span class="n">zs</span>
    <span class="n">zwrk</span> <span class="o">+=</span> <span class="p">(</span><span class="mf">1.296821e-6</span> <span class="o">*</span> <span class="n">zt</span> <span class="o">-</span> <span class="mf">5.782165e-9</span><span class="p">)</span> <span class="o">*</span> <span class="n">zt</span> <span class="o">+</span> <span class="mf">1.045941e-4</span>  <span class="c1"># zbw</span>

    <span class="c1"># zh * zb</span>
    <span class="n">zrho</span> <span class="o">=</span> <span class="n">zwrk</span> <span class="o">*</span> <span class="n">zh</span>

    <span class="c1"># za = (zd * zsr + zc) * zs + zaw</span>
    <span class="n">zwrk</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">7.267926e-5</span> <span class="o">*</span> <span class="n">zt</span> <span class="o">+</span> <span class="mf">2.598241e-3</span><span class="p">)</span> <span class="o">*</span> <span class="n">zt</span> <span class="o">+</span> <span class="mf">0.1571896</span>     <span class="c1"># zc</span>
    <span class="n">zwrk</span> <span class="o">+=</span> <span class="o">-</span><span class="mf">2.042967e-2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">zs</span><span class="p">)</span>          <span class="c1"># zd * zsr</span>
    <span class="n">zwrk</span> <span class="o">*=</span> <span class="n">zs</span>
    <span class="n">zwrk</span> <span class="o">+=</span> <span class="p">((</span><span class="mf">5.939910e-6</span> <span class="o">*</span> <span class="n">zt</span> <span class="o">+</span> <span class="mf">2.512549e-3</span><span class="p">)</span> <span class="o">*</span> <span class="n">zt</span> <span class="o">-</span> <span class="mf">0.1028859</span><span class="p">)</span> <span class="o">*</span> <span class="n">zt</span> <span class="o">-</span> <span class="mf">4.721788</span>       <span class="c1"># zaw</span>

    <span class="c1"># zh * (za - zh * zb)</span>
    <span class="n">zwrk</span> <span class="o">-=</span> <span class="n">zrho</span>
    <span class="n">zrho</span> <span class="o">=</span> <span class="n">zwrk</span> <span class="o">*</span> <span class="n">zh</span>

    <span class="c1"># zk0 = (zb1 * zsr + za1) * zs + zkw</span>
    <span class="n">zwrk</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.1909078</span> <span class="o">*</span> <span class="n">zt</span> <span class="o">+</span> <span class="mf">7.390729</span><span class="p">)</span> <span class="o">*</span> <span class="n">zt</span> <span class="o">-</span> <span class="mf">55.87545</span>         <span class="c1"># zb1</span>
    <span class="n">zwrk</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">zs</span><span class="p">)</span>                         <span class="c1"># zsr</span>
    <span class="n">zwrk</span> <span class="o">+=</span> <span class="p">((</span><span class="mf">2.326469e-3</span> <span class="o">*</span> <span class="n">zt</span> <span class="o">+</span> <span class="mf">1.553190</span><span class="p">)</span> <span class="o">*</span> <span class="n">zt</span> <span class="o">-</span> <span class="mf">65.00517</span><span class="p">)</span> <span class="o">*</span> <span class="n">zt</span> <span class="o">+</span> <span class="mf">1044.077</span>        <span class="c1"># za1</span>
    <span class="n">zwrk</span> <span class="o">*=</span> <span class="n">zs</span>
    <span class="n">zwrk</span> <span class="o">+=</span> <span class="p">(((</span><span class="o">-</span><span class="mf">1.361629e-4</span> <span class="o">*</span> <span class="n">zt</span> <span class="o">-</span> <span class="mf">1.852732e-2</span><span class="p">)</span> <span class="o">*</span> <span class="n">zt</span> <span class="o">-</span> <span class="mf">30.41638</span><span class="p">)</span> <span class="o">*</span> <span class="n">zt</span> <span class="o">+</span> <span class="mf">2098.925</span><span class="p">)</span> <span class="o">*</span> <span class="n">zt</span> <span class="o">+</span> <span class="mf">190925.6</span>        <span class="c1"># zkw</span>

    <span class="c1"># 1. - zh / (zk0 - zh * (za - zh * zb))</span>
    <span class="n">zwrk</span> <span class="o">-=</span> <span class="n">zrho</span>
    <span class="n">zrho</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">-</span> <span class="n">zh</span> <span class="o">/</span> <span class="n">zwrk</span>

    <span class="c1"># zrhop = (zr4 * zs + zr3 * zsr + zr2) * zs + zr1</span>
    <span class="n">zwrk</span> <span class="o">=</span> <span class="p">(((</span><span class="mf">5.3875e-9</span> <span class="o">*</span> <span class="n">zt</span> <span class="o">-</span> <span class="mf">8.2467e-7</span><span class="p">)</span> <span class="o">*</span> <span class="n">zt</span> <span class="o">+</span> <span class="mf">7.6438e-5</span><span class="p">)</span> <span class="o">*</span> <span class="n">zt</span> <span class="o">-</span> <span class="mf">4.0899e-3</span><span class="p">)</span> <span class="o">*</span> <span class="n">zt</span> <span class="o">+</span> <span class="mf">0.824493</span>        <span class="c1"># zr2</span>
    <span class="n">zwrk</span> <span class="o">+=</span> <span class="mf">4.8314e-4</span> <span class="o">*</span> <span class="n">zs</span>                      <span class="c1"># zr4 * zs</span>
    <span class="n">zwrk</span> <span class="o">+=</span> <span class="p">((</span><span class="o">-</span><span class="mf">1.6546e-6</span> <span class="o">*</span> <span class="n">zt</span> <span class="o">+</span> <span class="mf">1.0227e-4</span><span class="p">)</span> <span class="o">*</span> <span class="n">zt</span> <span class="o">-</span> <span class="mf">5.72466e-3</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">zs</span><span class="p">)</span>        <span class="c1"># zr3 * zsr</span>
    <span class="n">zwrk</span> <span class="o">*=</span> <span class="n">zs</span>
    <span class="n">zwrk</span> <span class="o">+=</span> <span class="p">((((</span><span class="mf">6.536332e-9</span> <span class="o">*</span> <span class="n">zt</span> <span class="o">-</span> <span class="mf">1.120083e-6</span><span class="p">)</span> <span class="o">*</span> <span class="n">zt</span> <span class="o">+</span> <span class="mf">1.001685e-4</span><span class="p">)</span> <span class="o">*</span> <span class="n">zt</span> <span class="o">-</span> <span class="mf">9.095290e-3</span><span class="p">)</span>
             <span class="o">*</span> <span class="n">zt</span> <span class="o">+</span> <span class="mf">6.793952e-2</span><span class="p">)</span> <span class="o">*</span> <span class="n">zt</span> <span class="o">+</span> <span class="mf">999.842594</span>   <span class="c1"># zr1</span>

    <span class="c1"># rho = zrhop / (1. - zh / (zk0 - zh * (za - zh * zb)))</span>
    <span class="n">zrho</span> <span class="o">=</span> <span class="n">zwrk</span> <span class="o">/</span> <span class="n">zrho</span>
    <span class="k">return</span> <span class="n">zrho</span></div>


<div class="viewcode-block" id="calc_loaddust"><a class="viewcode-back" href="../../../mip_convert/process/processors.html#mip_convert.process.processors.calc_loaddust">[docs]</a><span class="k">def</span> <span class="nf">calc_loaddust</span><span class="p">(</span><span class="n">total_dust_concentration</span><span class="p">,</span> <span class="n">grid_cell_volume</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the loaddust variable.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    total_dust_concentration :class:`iris.cube.Cube`</span>
<span class="sd">        Total dust concentration in micrograms/m-3</span>
<span class="sd">    grid_cell_volume :class:`iris.cube.Cube`</span>
<span class="sd">        UKCA Theta Grid Cell volume in m-3</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    loaddust: :class:`iris.cube.Cube`</span>
<span class="sd">        kg m-2</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Multiply cubes to find mass of dust per grid cell</span>
    <span class="n">dust_mass</span> <span class="o">=</span> <span class="n">total_dust_concentration</span> <span class="o">*</span> <span class="n">grid_cell_volume</span>
    <span class="c1"># Reduce dimensionality by summing the dust_mass over the height axis</span>
    <span class="n">total_dust_mass</span> <span class="o">=</span> <span class="n">dust_mass</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="s1">&#39;model_level_number&#39;</span><span class="p">,</span> <span class="n">SUM</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1.e-9</span>

    <span class="c1"># Remove extraneous altitude coordinates</span>
    <span class="n">total_dust_mass</span> <span class="o">=</span> <span class="n">remove_altitude_coords</span><span class="p">(</span><span class="n">total_dust_mass</span><span class="p">)</span>

    <span class="c1"># Create a cube to feed into areacella and calculate the areas of the grid box</span>
    <span class="n">cube_for_area</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">total_dust_mass</span><span class="o">.</span><span class="n">slices</span><span class="p">([</span><span class="s1">&#39;latitude&#39;</span><span class="p">,</span> <span class="s1">&#39;longitude&#39;</span><span class="p">]))</span>
    <span class="n">gridbox_area</span> <span class="o">=</span> <span class="n">areacella</span><span class="p">(</span><span class="n">cube_for_area</span><span class="p">)</span>

    <span class="c1"># Divide the total_dust_mass by the grid box area</span>
    <span class="n">loaddust</span> <span class="o">=</span> <span class="n">divide_cubes</span><span class="p">(</span><span class="n">total_dust_mass</span><span class="p">,</span> <span class="n">gridbox_area</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">loaddust</span></div>


<div class="viewcode-block" id="calc_rho_mean"><a class="viewcode-back" href="../../../mip_convert/process/processors.html#mip_convert.process.processors.calc_rho_mean">[docs]</a><span class="k">def</span> <span class="nf">calc_rho_mean</span><span class="p">(</span><span class="n">thetao</span><span class="p">,</span> <span class="n">so</span><span class="p">,</span> <span class="n">zfullo</span><span class="p">,</span> <span class="n">areacello</span><span class="p">,</span> <span class="n">thkcello</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the global mean in-situ density of seawater using a modified</span>
<span class="sd">    version of the Jackett and McDougall (1995) [calc_rho_mean_1]_</span>
<span class="sd">    equation of state.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    thetao: :class:`iris.cube.Cube`</span>
<span class="sd">        Potential temperature (degrees Celsius)</span>
<span class="sd">    so: :class:`iris.cube.Cube`</span>
<span class="sd">        Practical salinity (PSU)</span>
<span class="sd">    zfullo: :class:`iris.cube.Cube`</span>
<span class="sd">        Depth (m)</span>
<span class="sd">    areacello: :class:`iris.cube.Cube`</span>
<span class="sd">        Cell area (m2)</span>
<span class="sd">    thkcello: :class:`iris.cube.Cube`</span>
<span class="sd">        Cell thickness (m)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rho: :class:`iris.cube.Cube`</span>
<span class="sd">        Global mean in-situ density (kg/m3)</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    eos_insitu</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This is an :class:`iris.cube.Cube` wrapper to `eos_insitu`.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [calc_rho_mean_1]</span>
<span class="sd">        Jackett, D.R. and Mcdougall, T.J., 1995. Minimal adjustment of</span>
<span class="sd">        hydrographic profiles to achieve static</span>
<span class="sd">        stability. Journal of Atmospheric and Oceanic Technology,</span>
<span class="sd">        12(2), pp.381-389.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check data are consistent in shape</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">({</span><span class="n">thetao</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">so</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">zfullo</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">thkcello</span><span class="o">.</span><span class="n">shape</span><span class="p">})</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">message</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Input arguments have inconsistent shapes: &#39;</span>
                   <span class="s1">&#39;</span><span class="se">\n\t</span><span class="s1">thetao = </span><span class="si">{a.shape}</span><span class="s1">&#39;</span>
                   <span class="s1">&#39;</span><span class="se">\n\t</span><span class="s1">so = </span><span class="si">{b.shape}</span><span class="s1">&#39;</span>
                   <span class="s1">&#39;</span><span class="se">\n\t</span><span class="s1">zfullo = </span><span class="si">{c.shape}</span><span class="s1">&#39;</span>
                   <span class="s1">&#39;</span><span class="se">\n\t</span><span class="s1">thkcello = </span><span class="si">{d.shape}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">message</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">thetao</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">so</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">zfullo</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="n">thkcello</span><span class="p">))</span>

    <span class="c1"># Calculate in-situ density</span>
    <span class="n">rho</span> <span class="o">=</span> <span class="n">thetao</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">eos_insitu</span><span class="p">(</span><span class="n">thetao</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">so</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">zfullo</span><span class="o">.</span><span class="n">data</span><span class="p">))</span>

    <span class="c1"># Set some metadata</span>
    <span class="n">rho</span><span class="o">.</span><span class="n">standard_name</span> <span class="o">=</span> <span class="s1">&#39;sea_water_density&#39;</span>
    <span class="n">rho</span><span class="o">.</span><span class="n">long_name</span> <span class="o">=</span> <span class="s1">&#39;In situ density&#39;</span>
    <span class="n">rho</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="s1">&#39;kg m-3&#39;</span>

    <span class="c1"># Calculate weighted global mean</span>
    <span class="n">volcello</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">areacello</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">thkcello</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">*</span> <span class="n">thkcello</span><span class="o">.</span><span class="n">data</span>
    <span class="n">rho_mean</span> <span class="o">=</span> <span class="n">rho</span><span class="o">.</span><span class="n">collapsed</span><span class="p">([</span><span class="s1">&#39;latitude&#39;</span><span class="p">,</span> <span class="s1">&#39;longitude&#39;</span><span class="p">,</span> <span class="s1">&#39;depth&#39;</span><span class="p">],</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">MEAN</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">volcello</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">rho_mean</span></div>


<div class="viewcode-block" id="calc_zostoga"><a class="viewcode-back" href="../../../mip_convert/process/processors.html#mip_convert.process.processors.calc_zostoga">[docs]</a><span class="k">def</span> <span class="nf">calc_zostoga</span><span class="p">(</span><span class="n">thetao</span><span class="p">,</span> <span class="n">thkcello</span><span class="p">,</span> <span class="n">areacello</span><span class="p">,</span> <span class="n">zfullo_0</span><span class="p">,</span> <span class="n">so_0</span><span class="p">,</span> <span class="n">rho_0_mean</span><span class="p">,</span> <span class="n">deptho_0_mean</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the global mean thermosteric sea level change with</span>
<span class="sd">    respect to a reference state.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ---------</span>
<span class="sd">    thetao: :class:`iris.cube.Cube`</span>
<span class="sd">        Potential temperature (degrees Celsius)</span>
<span class="sd">    thkcello: :class:`iris.cube.Cube`</span>
<span class="sd">        Cell thickness (m)</span>
<span class="sd">    areacello: :class:`iris.cube.Cube`</span>
<span class="sd">        Cell area (m2)</span>
<span class="sd">    zfullo_0: :class:`iris.cube.Cube`</span>
<span class="sd">        **Reference state** depth (m)</span>
<span class="sd">    so_0: :class:`iris.cube.Cube`</span>
<span class="sd">        **Reference state** practical salinity (PSU)</span>
<span class="sd">    rho_0_mean: :class:`iris.cube.Cube`</span>
<span class="sd">        **Reference state** global mean in-situ density (kg/m3)</span>
<span class="sd">    deptho_0_mean: :class:`iris.cube.Cube`</span>
<span class="sd">        **Reference state** global mean water column depth (m),</span>
<span class="sd">        computed as the total volume (`volo`) divided by the total surface area</span>
<span class="sd">        (sum of `areacello`)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    zostoga: :class:`iris.cube.Cube`</span>
<span class="sd">        Global mean thermosteric sea level change (m)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Following eq. H27 of Griffies et al. (2016) [calc_zostoga_1]_:</span>

<span class="sd">        | `zostoga = (volo_0 / areao) * (1 - RHO_t)`</span>
<span class="sd">        | `RHO_t = RHO(thetao, so_0, p_0) / rho_0_mean`</span>

<span class="sd">    where:</span>

<span class="sd">        | `RHO` = Global mean in-situ density (kg/m3)</span>
<span class="sd">        | `p_0` = **Reference state** sea water pressure at model levels (dbar),</span>
<span class="sd">                    approximated by the depth `zfullo_0`</span>

<span class="sd">    The reference state is taken to be the first annual mean from the</span>
<span class="sd">    piControl experiment for a particular model configuration. This is used to</span>
<span class="sd">    calculate zostoga for all simulations based on this configuration.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [calc_zostoga_1]</span>
<span class="sd">        Griffies, S.M., Danabasoglu, G., Durack, P.J., Adcroft, A.J.,</span>
<span class="sd">        Balaji, V., Boning, C.W., Chassignet, E.P., Curchitser,</span>
<span class="sd">        E., Deshayes, J., Drange, H. and Fox-Kemper, B.,</span>
<span class="sd">        2016. OMIP contribution to CMIP6: experimental and diagnostic</span>
<span class="sd">        protocol for the physical component of the Ocean Model</span>
<span class="sd">        Intercomparison Project. Geoscientific Model Development,</span>
<span class="sd">        9(9), pp.3231-3296.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rho_mean</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">cube</span><span class="o">.</span><span class="n">CubeList</span><span class="p">()</span>

    <span class="n">so_0</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">so_0</span><span class="p">)</span>
    <span class="n">zfullo_0</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">zfullo_0</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">t_slice</span><span class="p">,</span> <span class="n">z_slice</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">thetao</span><span class="o">.</span><span class="n">slices_over</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">),</span> <span class="n">thkcello</span><span class="o">.</span><span class="n">slices_over</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">)):</span>
        <span class="c1"># Check that thetao and thkcello have the same time coordinate</span>
        <span class="n">t_time</span> <span class="o">=</span> <span class="n">t_slice</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">)</span>
        <span class="n">z_time</span> <span class="o">=</span> <span class="n">z_slice</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">t_time</span><span class="o">.</span><span class="n">cell</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">!=</span> <span class="n">z_time</span><span class="o">.</span><span class="n">cell</span><span class="p">(</span><span class="mi">0</span><span class="p">):</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s1">&#39;Time coordinates of thetao and thkcello do not match:</span><span class="se">\n\t</span><span class="s1">thetao: </span><span class="si">{}</span><span class="se">\n\t</span><span class="s1">thkcello: </span><span class="si">{}</span><span class="s1">&#39;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">message</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">t_time</span><span class="p">,</span> <span class="n">z_time</span><span class="p">))</span>

        <span class="c1"># Change in mean in-situ density due to temperature (vs reference state)</span>
        <span class="n">rho_mean</span> <span class="o">+=</span> <span class="p">[</span><span class="n">calc_rho_mean</span><span class="p">(</span><span class="n">t_slice</span><span class="p">,</span> <span class="n">so_0</span><span class="p">,</span> <span class="n">zfullo_0</span><span class="p">,</span> <span class="n">areacello</span><span class="p">,</span> <span class="n">z_slice</span><span class="p">)]</span>

    <span class="n">rho_mean</span> <span class="o">=</span> <span class="n">rho_mean</span><span class="o">.</span><span class="n">merge_cube</span><span class="p">()</span>
    <span class="n">rho_t</span> <span class="o">=</span> <span class="n">rho_mean</span><span class="o">.</span><span class="n">data</span> <span class="o">/</span> <span class="n">rho_0_mean</span><span class="o">.</span><span class="n">data</span>

    <span class="c1"># zostoga is calculated by restating the change in mean in-situ density as a change in mean sea surface height</span>
    <span class="n">zostoga</span> <span class="o">=</span> <span class="n">deptho_0_mean</span><span class="o">.</span><span class="n">data</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">rho_t</span><span class="p">)</span>
    <span class="n">zostoga</span> <span class="o">=</span> <span class="n">rho_mean</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">zostoga</span><span class="p">)</span>
    <span class="n">zostoga</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="n">Unit</span><span class="p">(</span><span class="s1">&#39;m&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">zostoga</span></div>


<div class="viewcode-block" id="trop_o3col"><a class="viewcode-back" href="../../../mip_convert/process/processors.html#mip_convert.process.processors.trop_o3col">[docs]</a><span class="k">def</span> <span class="nf">trop_o3col</span><span class="p">(</span><span class="n">o3mass</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function will generate a &#39;Tropospheric Ozone Column&#39; diagnostic.</span>

<span class="sd">    Method:</span>
<span class="sd">     - Expected input is Ozone MMR x Tropmask x Airmass i.e.</span>
<span class="sd">        ozone mass as kg per gridbox</span>
<span class="sd">     - Sum over levels to get total O3 mass in column and convert to moles</span>
<span class="sd">     - Calculate num of O3 molecules using Avogadro&#39;s number (molecules/mole)</span>
<span class="sd">     - Divide by cell area to obtain O3 molecules/m2</span>
<span class="sd">     - Convert to Dobson Units DU using factor for molec/m2 --&gt; DU</span>

<span class="sd">    All Constants used in calculations are from UKCA_CONSTANTS_MOD as of UM10.8</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">      o3mass: class:`iris.cube.Cube`: Ozone mass in gridbox (kg)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    : :class:`iris.cube.Cube`: Tropospheric ozone column in DU.</span>
<span class="sd">       Expected to have a single-level representing the whole column.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">avogadro</span> <span class="o">=</span> <span class="mf">6.022e+23</span>      <span class="c1"># Avogadro&#39;s num, molecules/mol of gas</span>
    <span class="n">mwt_o3</span> <span class="o">=</span> <span class="mf">0.048</span>            <span class="c1"># Molecular wt O3 - kg/mol</span>
    <span class="n">du_fact</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mf">2.685e20</span>  <span class="c1"># Factor for converting from molec/m2 --&gt; DU</span>

    <span class="c1"># Calculate grid areas</span>
    <span class="n">grid_areas</span> <span class="o">=</span> <span class="n">areacella</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">o3mass</span><span class="o">.</span><span class="n">slices</span><span class="p">([</span><span class="s1">&#39;latitude&#39;</span><span class="p">,</span> <span class="s1">&#39;longitude&#39;</span><span class="p">])))</span>

    <span class="c1"># Sum over levels and create output cube</span>
    <span class="n">trop_o3col</span> <span class="o">=</span> <span class="n">o3mass</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="s1">&#39;model_level_number&#39;</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">SUM</span><span class="p">)</span>
    <span class="n">o3mass</span> <span class="o">=</span> <span class="s1">&#39;a&#39;</span>  <span class="c1"># free memory</span>

    <span class="c1"># Calculate no. of molecules as :</span>
    <span class="c1">#  mass kg x 1/molewt mol  x Avogadro molecules)</span>
    <span class="c1">#                    ----              -------</span>
    <span class="c1">#                     kg                mol</span>
    <span class="n">trop_o3col</span> <span class="o">=</span> <span class="n">trop_o3col</span> <span class="o">*</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">mwt_o3</span> <span class="o">*</span> <span class="n">avogadro</span>

    <span class="c1"># Divide by area to get molecules/m2 and convert to DU</span>
    <span class="n">trop_o3col</span><span class="o">.</span><span class="n">data</span> <span class="o">/=</span> <span class="n">grid_areas</span><span class="o">.</span><span class="n">data</span>
    <span class="n">trop_o3col</span> <span class="o">*=</span> <span class="n">du_fact</span>

    <span class="k">return</span> <span class="n">trop_o3col</span></div>


<div class="viewcode-block" id="mmr2molefrac"><a class="viewcode-back" href="../../../mip_convert/process/processors.html#mip_convert.process.processors.mmr2molefrac">[docs]</a><span class="k">def</span> <span class="nf">mmr2molefrac</span><span class="p">(</span><span class="n">mass</span><span class="p">,</span> <span class="n">incube</span><span class="p">,</span> <span class="n">molmass</span><span class="p">,</span> <span class="n">climatology</span><span class="o">=</span><span class="s1">&#39;False&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function converts a 3-D (or 4-D) Mass-mixing-ratio cube to a global</span>
<span class="sd">    (and annual) mean molefraction</span>

<span class="sd">    Steps:</span>
<span class="sd">      - Convert the mass-mixing-ratio to mass-of-species using gridbox air mass</span>
<span class="sd">      - Convert mass of sp and mass of air into moles</span>
<span class="sd">      - Mean over lat,long,levels(,time) to obtain global mean species as well</span>
<span class="sd">        as airmass</span>
<span class="sd">      - Divide moles species with moles air and obtain mole/mole fraction</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mass: :class:`iris.cube.Cube` containing 3-D grid-cell mass</span>
<span class="sd">    incube: class:`iris.cube.Cube` containing mass-mixing-ratio of species</span>
<span class="sd">    molmass: scalar: Molecular mass of species</span>
<span class="sd">    climatology: boolean: flag to control whether to mean time dimension</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    :  :class:`iris.cube.Cube` containing scalar value or 1d(time) array</span>
<span class="sd">        as (moles of species/moles of air)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">class</span> <span class="nc">MfracError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="n">funcname</span> <span class="o">=</span> <span class="s1">&#39;mmr2molefrac&#39;</span>
    <span class="n">molmass_air</span> <span class="o">=</span> <span class="mf">28.97</span>  <span class="c1"># g mol-1 (or import from constants.py?)</span>

    <span class="k">if</span> <span class="n">incube</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">mass</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">MfracError</span><span class="p">(</span><span class="n">funcname</span> <span class="o">+</span> <span class="s1">&#39;: Field and Airmass shapes do not match &#39;</span><span class="p">)</span>

    <span class="c1"># Axes to collapse</span>
    <span class="n">coord_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;model_level_number&#39;</span><span class="p">,</span> <span class="s1">&#39;latitude&#39;</span><span class="p">,</span> <span class="s1">&#39;longitude&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">climatology</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;true&#39;</span><span class="p">:</span>
        <span class="n">coord_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="s1">&#39;model_level_number&#39;</span><span class="p">,</span> <span class="s1">&#39;latitude&#39;</span><span class="p">,</span> <span class="s1">&#39;longitude&#39;</span><span class="p">]</span>

    <span class="c1"># multiply input cube by mass to obtain total as kg species,</span>
    <span class="c1"># mean over the grid and convert to moles. Same for airmass</span>
    <span class="n">incube</span> <span class="o">*=</span> <span class="n">mass</span>
    <span class="n">spec_1d</span> <span class="o">=</span> <span class="n">incube</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="n">coord_names</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">MEAN</span><span class="p">)</span> <span class="o">*</span> <span class="n">molmass</span>
    <span class="n">mass1d</span> <span class="o">=</span> <span class="n">mass</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="n">coord_names</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">MEAN</span><span class="p">)</span> <span class="o">*</span> <span class="n">molmass_air</span>
    <span class="n">spec_1d</span> <span class="o">/=</span> <span class="n">mass1d</span>   <span class="c1"># Moles of sp/ moles of air</span>
    <span class="k">return</span> <span class="n">spec_1d</span></div>


<div class="viewcode-block" id="combine_sw_lw"><a class="viewcode-back" href="../../../mip_convert/process/processors.html#mip_convert.process.processors.combine_sw_lw">[docs]</a><span class="k">def</span> <span class="nf">combine_sw_lw</span><span class="p">(</span><span class="n">swcube</span><span class="p">,</span> <span class="n">lwcube</span><span class="p">,</span> <span class="n">swmask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">minval</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">maxval</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Combine cubes containing ShortWave and LongWave band (pseudo-levels)</span>
<span class="sd">    into a single cube with extended pslev dimension</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        swcube: class:`iris.cube.Cube` containing field on SW bands</span>
<span class="sd">        lwcube: class:`iris.cube.Cube` containing field on LW bands</span>
<span class="sd">        keyword args:</span>
<span class="sd">          swmask: class:`iris.cube.Cube` for lit-points mask (SW)</span>
<span class="sd">          minval: Float: expected minimum value of output field</span>
<span class="sd">          maxval: Float: expected maximum value of output field</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        : :class:`iris.cube.Cube` representing requested diagnostic on model</span>
<span class="sd">                 levels and ShortWave + LongWave bands</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Serialise wavelength band values in LW cube, starting from end of SW for concatenate to work</span>
    <span class="n">lwbands</span> <span class="o">=</span> <span class="n">lwcube</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="s1">&#39;pseudo_level&#39;</span><span class="p">)</span>
    <span class="n">n_lw</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lwbands</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
    <span class="n">n_sw</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">swcube</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="s1">&#39;pseudo_level&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
    <span class="n">lwbands</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_sw</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_sw</span> <span class="o">+</span> <span class="n">n_lw</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

    <span class="c1"># Apply mask for SW cube, looping over t,lat,lon slices.</span>
    <span class="c1"># Also need to reset names, attributes to allow concatenation</span>
    <span class="c1"># This is not needed if arguments are received as division of two cubes,</span>
    <span class="c1"># wherein these parameters are already reset.</span>
    <span class="k">if</span> <span class="n">swmask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">swmask</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">cube</span><span class="o">.</span><span class="n">Cube</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39; Sunlit mask field expected as a cube&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">sw_cub</span> <span class="ow">in</span> <span class="n">swcube</span><span class="o">.</span><span class="n">slices</span><span class="p">([</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="s1">&#39;latitude&#39;</span><span class="p">,</span> <span class="s1">&#39;longitude&#39;</span><span class="p">]):</span>
            <span class="n">sw_cub</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_invalid</span><span class="p">(</span><span class="n">sw_cub</span><span class="o">.</span><span class="n">data</span> <span class="o">/</span> <span class="n">swmask</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">cb</span> <span class="ow">in</span> <span class="p">[</span><span class="n">swcube</span><span class="p">,</span> <span class="n">lwcube</span><span class="p">]:</span>
            <span class="n">cb</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s1">&#39;unknown&#39;</span><span class="p">)</span>
            <span class="k">del</span><span class="p">(</span><span class="n">cb</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="s1">&#39;STASH&#39;</span><span class="p">])</span>

    <span class="c1"># Create a cube-list and concatenate</span>
    <span class="n">cube_list</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">cube</span><span class="o">.</span><span class="n">CubeList</span><span class="p">([</span><span class="n">swcube</span><span class="p">,</span> <span class="n">lwcube</span><span class="p">])</span>
    <span class="n">oucube</span> <span class="o">=</span> <span class="n">cube_list</span><span class="o">.</span><span class="n">concatenate_cube</span><span class="p">()</span>

    <span class="c1"># Change pseudo_level units and then the dimension order to</span>
    <span class="c1"># (time, waveband, level, lat, long) to match output requirements</span>
    <span class="n">oucube</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="s1">&#39;pseudo_level&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="s1">&#39;m-1&#39;</span>
    <span class="n">oucube</span><span class="o">.</span><span class="n">transpose</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>

    <span class="c1"># Ensure that final values are between limits, if specified</span>
    <span class="k">if</span> <span class="n">minval</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">min_val</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">minval</span><span class="p">)</span>
        <span class="n">oucube</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">oucube</span><span class="o">.</span><span class="n">data</span> <span class="o">&lt;</span> <span class="n">min_val</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_val</span>
    <span class="k">if</span> <span class="n">maxval</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">max_val</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">maxval</span><span class="p">)</span>
        <span class="n">oucube</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">oucube</span><span class="o">.</span><span class="n">data</span> <span class="o">&gt;</span> <span class="n">max_val</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_val</span>

    <span class="k">return</span> <span class="n">oucube</span></div>


<div class="viewcode-block" id="ocean_quasi_barotropic_streamfunc"><a class="viewcode-back" href="../../../mip_convert/process/processors.html#mip_convert.process.processors.ocean_quasi_barotropic_streamfunc">[docs]</a><span class="k">def</span> <span class="nf">ocean_quasi_barotropic_streamfunc</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="n">areacello</span><span class="p">,</span> <span class="n">cube_mask</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the quasi-barotropic streamfunction from the vertically integrated</span>
<span class="sd">    zonal mass transport.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cube: :class:`iris.cube.Cube`</span>
<span class="sd">        A cube containing the vertically integrated zonal mass transport.</span>
<span class="sd">    areacello: :class:`iris.cube.Cube`</span>
<span class="sd">        A cube containing the grid cell area.</span>
<span class="sd">    cube_mask: :class:`iris.cube.Cube`, optional</span>
<span class="sd">        A cube containing the mask to be applied (1 where masked, else 0).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    cube: :class:`iris.cube.Cube`</span>
<span class="sd">        A cube containing the quasi-barotropic streamfunction.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Integrate over the y axis (U to F grid)</span>
    <span class="n">dims</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">coord_dims</span><span class="p">(</span><span class="n">cube</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="s1">&#39;latitude&#39;</span><span class="p">))</span>
    <span class="n">data_array</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="c1"># Regrid from F to T grid. Note that no area weighting is used;</span>
    <span class="c1"># we assume the only purpose of this diagnostic is visualisation.</span>
    <span class="n">cube</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.25</span> <span class="o">*</span> <span class="p">(</span><span class="n">data_array</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                                      <span class="o">+</span> <span class="n">data_array</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span>
                                      <span class="o">+</span> <span class="n">data_array</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">:]</span>
                                      <span class="o">+</span> <span class="n">data_array</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="n">cube</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.25</span> <span class="o">*</span> <span class="p">(</span><span class="n">data_array</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                                     <span class="o">+</span> <span class="n">data_array</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                                     <span class="o">+</span> <span class="n">data_array</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">:,</span> <span class="mi">0</span><span class="p">]</span>
                                     <span class="o">+</span> <span class="n">data_array</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="c1"># Copy T grid coordinates from areacello</span>
    <span class="n">cube</span><span class="o">.</span><span class="n">remove_coord</span><span class="p">(</span><span class="s1">&#39;longitude&#39;</span><span class="p">)</span>
    <span class="n">cube</span><span class="o">.</span><span class="n">remove_coord</span><span class="p">(</span><span class="s1">&#39;latitude&#39;</span><span class="p">)</span>
    <span class="n">cube</span><span class="o">.</span><span class="n">add_aux_coord</span><span class="p">(</span><span class="n">areacello</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="s1">&#39;latitude&#39;</span><span class="p">),</span> <span class="n">data_dims</span><span class="o">=</span><span class="n">dims</span><span class="p">)</span>
    <span class="n">cube</span><span class="o">.</span><span class="n">add_aux_coord</span><span class="p">(</span><span class="n">areacello</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="s1">&#39;longitude&#39;</span><span class="p">),</span> <span class="n">data_dims</span><span class="o">=</span><span class="n">dims</span><span class="p">)</span>

    <span class="c1"># Apply land-sea mask</span>
    <span class="k">if</span> <span class="n">cube_mask</span><span class="p">:</span>
        <span class="n">cube</span> <span class="o">=</span> <span class="n">mask_copy</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="n">cube_mask</span><span class="p">)</span>

    <span class="c1"># Mask the bottom row (invalid after regridding)</span>
    <span class="n">cube</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked</span>
    <span class="k">return</span> <span class="n">cube</span></div>


<div class="viewcode-block" id="achem_emdrywet"><a class="viewcode-back" href="../../../mip_convert/process/processors.html#mip_convert.process.processors.achem_emdrywet">[docs]</a><span class="k">def</span> <span class="nf">achem_emdrywet</span><span class="p">(</span><span class="n">mfac</span><span class="p">,</span> <span class="n">incube</span><span class="p">,</span> <span class="n">cube2d</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sumlev</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">areadiv</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function produces Aerosol and Chemistry emission, dry- and</span>
<span class="sd">    wet-deposition diagnostics via common operations on the input cube.</span>

<span class="sd">    The common operations required are a combination of:</span>
<span class="sd">     - add surface values to multi-level cubes</span>
<span class="sd">     - collapse along Z dimension</span>
<span class="sd">     - divide by grid-cell area</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mfac: scalar: Molecular mass of species, to convert from moles to kg</span>
<span class="sd">    incube: class:`iris.cube.Cube` input 3-D cube (can be a sum of cubes)</span>
<span class="sd">            and units mostly as moles/gridbox/s</span>
<span class="sd">    cube2d: class:`iris.cube.Cube` input 2-D cube (can be a sum of cubes)</span>
<span class="sd">    sumlev: Boolean: whether to collapse the cube in Z dimension</span>
<span class="sd">    areadiv: Boolean: whether to divide by grid-area</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    :  :class:`iris.cube.Cube` usually 2-D and units of kg/m2/s</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Add any 2-D cubes if supplied</span>
    <span class="k">if</span> <span class="n">cube2d</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cube2d</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">cube</span><span class="o">.</span><span class="n">Cube</span><span class="p">):</span>
        <span class="n">incube</span> <span class="o">=</span> <span class="n">sum_2d_and_3d</span><span class="p">(</span><span class="n">cube2d</span><span class="p">,</span> <span class="n">incube</span><span class="p">)</span>

    <span class="n">incube</span><span class="o">.</span><span class="n">data</span> <span class="o">*=</span> <span class="n">mfac</span>     <span class="c1"># Apply mole -&gt; kg factor</span>

    <span class="c1"># Sum Z dim if requested</span>
    <span class="n">zdim</span> <span class="o">=</span> <span class="n">incube</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="n">dim_coords</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;Z&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sumlev</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">zdim</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">incube</span> <span class="o">=</span> <span class="n">incube</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="n">zdim</span><span class="o">.</span><span class="n">name</span><span class="p">(),</span> <span class="n">SUM</span><span class="p">)</span>

    <span class="c1"># Divide by area if needed</span>
    <span class="k">if</span> <span class="n">areadiv</span><span class="p">:</span>
        <span class="n">incube</span> <span class="o">=</span> <span class="n">div_by_area</span><span class="p">(</span><span class="n">incube</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">incube</span></div>


<div class="viewcode-block" id="volcello"><a class="viewcode-back" href="../../../mip_convert/process/processors.html#mip_convert.process.processors.volcello">[docs]</a><span class="k">def</span> <span class="nf">volcello</span><span class="p">(</span><span class="n">thkcello</span><span class="p">,</span> <span class="n">areacello</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the ocean cell volume, product of thkcello (4D) and</span>
<span class="sd">    areacello (2D).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    thkcello : :class:`iris.cube.Cube`</span>
<span class="sd">        Cell thickness cube.</span>
<span class="sd">    arecello : :class:`iris.cube.Cube`</span>
<span class="sd">        Cell area cube.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    : :class:`iris.cube.Cube`</span>
<span class="sd">        Volume cube</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">volcello</span> <span class="o">=</span> <span class="n">thkcello</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">volcello</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="s1">&#39;m3&#39;</span>
    <span class="n">volcello</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">thkcello</span><span class="o">.</span><span class="n">data</span> <span class="o">*</span> <span class="n">areacello</span><span class="o">.</span><span class="n">data</span>
    <span class="k">return</span> <span class="n">volcello</span></div>


<div class="viewcode-block" id="combine_cubes_to_basin_coord"><a class="viewcode-back" href="../../../mip_convert/process/processors.html#mip_convert.process.processors.combine_cubes_to_basin_coord">[docs]</a><span class="k">def</span> <span class="nf">combine_cubes_to_basin_coord</span><span class="p">(</span><span class="n">cube_global</span><span class="p">,</span> <span class="n">cube_atl</span><span class="p">,</span> <span class="n">cube_indpac</span><span class="p">,</span> <span class="n">mask_global</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mask_atl</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mask_indpac</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Combine data for individual basins into a single cube with a basin dimension.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cube_global: :class:`iris.cube.Cube`</span>
<span class="sd">        A cube with a latitude dimension and optionally a vertical dimension</span>
<span class="sd">        representing global ocean</span>
<span class="sd">    cube_atl: :class:`iris.cube.Cube`</span>
<span class="sd">        A cube with a latitude dimension and optionally a vertical dimension</span>
<span class="sd">        representing Atlantic (and Arctic) ocean</span>
<span class="sd">    cube_indpac: :class:`iris.cube.Cube`</span>
<span class="sd">        A cube with a latitude dimension and optionally a vertical dimension</span>
<span class="sd">        representing Indian and Pacific oceans</span>
<span class="sd">    mask_global: :class:`iris.cube.Cube`, optional</span>
<span class="sd">        A cube containing the mask to be applied to `cube_global`</span>
<span class="sd">        (1 where masked, else 0).</span>
<span class="sd">    mask_atl: :class:`iris.cube.Cube`, optional</span>
<span class="sd">        A cube containing the mask to be applied to `cube_atl`</span>
<span class="sd">        (1 where masked, else 0).</span>
<span class="sd">    mask_indpac: :class:`iris.cube.Cube`, optional</span>
<span class="sd">        A cube containing the mask to be applied to `cube_indpac`</span>
<span class="sd">        (1 where masked, else 0).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    : :class:`iris.cube.Cube`</span>
<span class="sd">       A cube containing all input cubes with an added basin dimension</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Make long_name, standard name and varname match</span>
    <span class="k">for</span> <span class="n">cube</span> <span class="ow">in</span> <span class="p">[</span><span class="n">cube_atl</span><span class="p">,</span> <span class="n">cube_indpac</span><span class="p">]:</span>
        <span class="n">cube</span><span class="o">.</span><span class="n">long_name</span> <span class="o">=</span> <span class="n">cube_global</span><span class="o">.</span><span class="n">long_name</span>
        <span class="n">cube</span><span class="o">.</span><span class="n">standard_name</span> <span class="o">=</span> <span class="n">cube_global</span><span class="o">.</span><span class="n">standard_name</span>
        <span class="n">cube</span><span class="o">.</span><span class="n">var_name</span> <span class="o">=</span> <span class="n">cube_global</span><span class="o">.</span><span class="n">var_name</span>

    <span class="n">cubes</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;global_ocean&#39;</span><span class="p">:</span> <span class="n">cube_global</span><span class="p">,</span>
             <span class="s1">&#39;atlantic_arctic_ocean&#39;</span><span class="p">:</span> <span class="n">cube_atl</span><span class="p">,</span>
             <span class="s1">&#39;indian_pacific_ocean&#39;</span><span class="p">:</span> <span class="n">cube_indpac</span><span class="p">}</span>
    <span class="n">masks</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;global_ocean&#39;</span><span class="p">:</span> <span class="n">mask_global</span><span class="p">,</span>
             <span class="s1">&#39;atlantic_arctic_ocean&#39;</span><span class="p">:</span> <span class="n">mask_atl</span><span class="p">,</span>
             <span class="s1">&#39;indian_pacific_ocean&#39;</span><span class="p">:</span> <span class="n">mask_indpac</span><span class="p">}</span>

    <span class="n">clist</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">cube</span><span class="o">.</span><span class="n">CubeList</span><span class="p">()</span>

    <span class="c1"># Loop over each cube argument</span>
    <span class="k">for</span> <span class="n">basin</span><span class="p">,</span> <span class="n">cube_basin</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">cubes</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
        <span class="n">coord</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">AuxCoord</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">basin</span><span class="p">),</span> <span class="n">standard_name</span><span class="o">=</span><span class="s1">&#39;region&#39;</span><span class="p">,</span> <span class="n">long_name</span><span class="o">=</span><span class="s1">&#39;ocean basin&#39;</span><span class="p">)</span>

        <span class="n">cube_basin</span><span class="o">.</span><span class="n">add_aux_coord</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>

        <span class="c1"># Remove single-length &#39;x&#39; dimension if present</span>
        <span class="n">lat_shape</span> <span class="o">=</span> <span class="n">cube_basin</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="s1">&#39;latitude&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lat_shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">lat_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">cube_basin</span> <span class="o">=</span> <span class="n">cube_basin</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Apply mask if supplied</span>
        <span class="k">if</span> <span class="n">masks</span><span class="p">[</span><span class="n">basin</span><span class="p">]:</span>
            <span class="n">mask_copy</span><span class="p">(</span><span class="n">cube_basin</span><span class="p">,</span> <span class="n">masks</span><span class="p">[</span><span class="n">basin</span><span class="p">])</span>

        <span class="n">clist</span> <span class="o">+=</span> <span class="p">[</span><span class="n">cube_basin</span><span class="p">]</span>

    <span class="c1"># Combine cubes along basin dimension</span>
    <span class="n">equalise_attributes</span><span class="p">(</span><span class="n">clist</span><span class="p">)</span>
    <span class="n">cube</span> <span class="o">=</span> <span class="n">clist</span><span class="o">.</span><span class="n">merge_cube</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">cube</span></div>


<div class="viewcode-block" id="land_use_tile_mean"><a class="viewcode-back" href="../../../mip_convert/process/processors.html#mip_convert.process.processors.land_use_tile_mean">[docs]</a><span class="k">def</span> <span class="nf">land_use_tile_mean</span><span class="p">(</span><span class="n">variable_cube</span><span class="p">,</span> <span class="n">tile_fraction_cube</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the cube of the mean variable_cube over the CMIP6 land use types.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    variable_cube: class:`iris.cube.Cube`</span>
<span class="sd">                  the cube containing the input variable on the JULES tiles.</span>
<span class="sd">    tile_fraction_cube: class:`iris.cube.Cube`</span>
<span class="sd">                  the fraction of land covered by each JULES tile.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    : class:`iris.cube.Cube`</span>
<span class="sd">        The mean of variable_cube over CMIP6 land use types.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Some variables are not available on all UM land surface tiles</span>
    <span class="c1"># e.g. LAI is only available on vegetation tiles, so we can only apply</span>
    <span class="c1"># calculations on the available tiles.</span>
    <span class="n">ps_lev_constraint</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">Constraint</span><span class="p">(</span><span class="n">pseudo_level</span><span class="o">=</span><span class="n">variable_cube</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="s2">&quot;pseudo_level&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
    <span class="n">tile_fraction_cube</span> <span class="o">=</span> <span class="n">tile_fraction_cube</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">ps_lev_constraint</span><span class="p">)</span>

    <span class="c1"># Label each UM land surface tile with a CMIP &quot;Land Use Tile&quot; id.</span>
    <span class="n">add_categorised_coord</span><span class="p">(</span><span class="n">variable_cube</span><span class="p">,</span> <span class="s1">&#39;lut&#39;</span><span class="p">,</span> <span class="s1">&#39;pseudo_level&#39;</span><span class="p">,</span> <span class="n">_lut_categorisation</span><span class="p">)</span>
    <span class="n">add_categorised_coord</span><span class="p">(</span><span class="n">tile_fraction_cube</span><span class="p">,</span> <span class="s1">&#39;lut&#39;</span><span class="p">,</span> <span class="s1">&#39;pseudo_level&#39;</span><span class="p">,</span> <span class="n">_lut_categorisation</span><span class="p">)</span>

    <span class="c1"># Aggregated_by can not calculate weighted means, so we need to apply</span>
    <span class="c1"># weightings before aggregating. Aggregated_by does not support lazy</span>
    <span class="c1"># evaluation, so we need to access data before aggregating.</span>
    <span class="n">variable_cube</span> <span class="o">=</span> <span class="n">variable_cube</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">variable_cube</span><span class="o">.</span><span class="n">data</span> <span class="o">*</span> <span class="n">tile_fraction_cube</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

    <span class="c1"># Not all UM land surface tiles can be assigned a CMIP Land Use Tile id</span>
    <span class="c1"># so extract only UM tiles which fall within the CMIP tile classification.</span>
    <span class="n">land_use_constraint</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">Constraint</span><span class="p">(</span><span class="n">lut</span><span class="o">=</span><span class="k">lambda</span> <span class="n">cell</span><span class="p">:</span> <span class="n">cell</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">variable_cube</span> <span class="o">=</span> <span class="p">(</span><span class="n">variable_cube</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">land_use_constraint</span><span class="p">)</span><span class="o">.</span><span class="n">aggregated_by</span><span class="p">([</span><span class="s1">&#39;lut&#39;</span><span class="p">],</span> <span class="n">SUM</span><span class="p">))</span>
    <span class="n">tile_fraction_cube</span> <span class="o">=</span> <span class="p">(</span><span class="n">tile_fraction_cube</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">land_use_constraint</span><span class="p">)</span><span class="o">.</span><span class="n">aggregated_by</span><span class="p">([</span><span class="s1">&#39;lut&#39;</span><span class="p">],</span> <span class="n">SUM</span><span class="p">))</span>

    <span class="n">output_cube</span> <span class="o">=</span> <span class="n">variable_cube</span> <span class="o">/</span> <span class="n">tile_fraction_cube</span>

    <span class="c1"># Finalize the lut dimension: check the length, order and naming</span>
    <span class="k">return</span> <span class="n">_finalize_lut_cube</span><span class="p">(</span><span class="n">output_cube</span><span class="p">)</span></div>


<div class="viewcode-block" id="land_use_tile_area"><a class="viewcode-back" href="../../../mip_convert/process/processors.html#mip_convert.process.processors.land_use_tile_area">[docs]</a><span class="k">def</span> <span class="nf">land_use_tile_area</span><span class="p">(</span><span class="n">tile_fraction_cube</span><span class="p">,</span> <span class="n">land_fraction_cube</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns cube of land cover fraction over the CMIP6 land use types.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tile_fraction_cube: class:`iris.cube.Cube`</span>
<span class="sd">                  the fraction of land covered by each JULES tile.</span>
<span class="sd">    land_fraction_cube: class:`iris.cube.Cube`</span>
<span class="sd">                  the fraction of a gridcell covered by land</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    : class:`iris.cube.Cube`</span>
<span class="sd">        An iris cube of land cover fraction.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Label each UM land surface tile with a CMIP &quot;Land Use Tile&quot; number.</span>
    <span class="n">add_categorised_coord</span><span class="p">(</span><span class="n">tile_fraction_cube</span><span class="p">,</span> <span class="s1">&#39;lut&#39;</span><span class="p">,</span> <span class="s1">&#39;pseudo_level&#39;</span><span class="p">,</span> <span class="n">_lut_categorisation</span><span class="p">)</span>

    <span class="c1"># Aggregated_by does not support lazy evaluation, so we need to access the data before aggregating.</span>
    <span class="n">tile_fraction_cube</span> <span class="o">=</span> <span class="n">tile_fraction_cube</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">tile_fraction_cube</span><span class="o">.</span><span class="n">data</span> <span class="o">*</span> <span class="n">land_fraction_cube</span><span class="o">.</span><span class="n">data</span> <span class="o">*</span> <span class="mf">100.0</span><span class="p">)</span>
    <span class="n">tile_fraction_cube</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="s2">&quot;%&quot;</span>

    <span class="c1"># Not all UM land surface tiles can be assigned a CMIP Land Use Tile id,</span>
    <span class="c1"># so extract only UM tiles which fall within the CMIP tile classification.</span>
    <span class="n">lut_constraint</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">Constraint</span><span class="p">(</span><span class="n">lut</span><span class="o">=</span><span class="k">lambda</span> <span class="n">cell</span><span class="p">:</span> <span class="n">cell</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">tile_fraction_cube</span> <span class="o">=</span> <span class="p">(</span><span class="n">tile_fraction_cube</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">lut_constraint</span><span class="p">)</span><span class="o">.</span><span class="n">aggregated_by</span><span class="p">([</span><span class="s1">&#39;lut&#39;</span><span class="p">],</span> <span class="n">SUM</span><span class="p">))</span>

    <span class="c1">#  Re-order the land use tile dimension.</span>
    <span class="n">lut_order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">tile_fraction_cube</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="s2">&quot;lut&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
    <span class="n">tile_fraction_cube</span> <span class="o">=</span> <span class="n">tile_fraction_cube</span><span class="p">[</span><span class="n">lut_order</span><span class="p">]</span>

    <span class="c1"># Label each UM land surface tile with a CMIP &quot;Land Use Tile&quot; name.</span>
    <span class="n">add_categorised_coord</span><span class="p">(</span><span class="n">tile_fraction_cube</span><span class="p">,</span> <span class="s1">&#39;landUse&#39;</span><span class="p">,</span> <span class="s1">&#39;lut&#39;</span><span class="p">,</span> <span class="n">_lut_area_type</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tile_fraction_cube</span></div>


<div class="viewcode-block" id="land_use_tile_mean_difference"><a class="viewcode-back" href="../../../mip_convert/process/processors.html#mip_convert.process.processors.land_use_tile_mean_difference">[docs]</a><span class="k">def</span> <span class="nf">land_use_tile_mean_difference</span><span class="p">(</span><span class="n">tile_fraction1</span><span class="p">,</span> <span class="n">tile_fraction2</span><span class="p">,</span> <span class="n">land_fraction_cube</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns cube of land cover fraction over the CMIP6 land use types,</span>
<span class="sd">    based on difference between the first 2 cubes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tile_fraction1: class:`iris.cube.Cube`</span>
<span class="sd">                  the fraction of land covered by each JULES tile.</span>
<span class="sd">    tile_fraction2: class:`iris.cube.Cube`</span>
<span class="sd">                  the fraction of land covered by each JULES tile.</span>
<span class="sd">    land_fraction_cube: class:`iris.cube.Cube`</span>
<span class="sd">                  the fraction of a gridcell covered by land</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    : class:`iris.cube.Cube`</span>
<span class="sd">        An iris cube of land cover fraction.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tile_fraction_cube</span> <span class="o">=</span> <span class="n">tile_fraction1</span> <span class="o">-</span> <span class="n">tile_fraction2</span>
    <span class="n">tile_mean_cube</span> <span class="o">=</span> <span class="n">land_use_tile_mean</span><span class="p">(</span><span class="n">tile_fraction_cube</span><span class="p">,</span> <span class="n">land_fraction_cube</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tile_mean_cube</span></div>


<div class="viewcode-block" id="divide_cubes"><a class="viewcode-back" href="../../../mip_convert/process/processors.html#mip_convert.process.processors.divide_cubes">[docs]</a><span class="k">def</span> <span class="nf">divide_cubes</span><span class="p">(</span><span class="n">cube1</span><span class="p">,</span> <span class="n">cube2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Divide cube1 by cube2, ignoring any differing coordinates.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cube1: :class:`iris.cube.Cube`</span>
<span class="sd">        The first cube.</span>
<span class="sd">    cube2: :class:`iris.cube.Cube`</span>
<span class="sd">        The second cube.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    : class:`iris.cube.Cube`</span>
<span class="sd">        The result of dividing the first cube by the second cube.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cube1</span><span class="p">,</span> <span class="n">cube2</span> <span class="o">=</span> <span class="n">_unify_coordinates</span><span class="p">(</span><span class="n">cube1</span><span class="p">,</span> <span class="n">cube2</span><span class="p">)</span>
    <span class="n">cube</span> <span class="o">=</span> <span class="n">cube1</span> <span class="o">/</span> <span class="n">cube2</span>
    <span class="k">return</span> <span class="n">cube</span></div>


<span class="k">def</span> <span class="nf">_unify_coordinates</span><span class="p">(</span><span class="n">cube1</span><span class="p">,</span> <span class="n">cube2</span><span class="p">):</span>
    <span class="c1"># Retrieve the logger.</span>
    <span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

    <span class="n">coord_names1</span> <span class="o">=</span> <span class="p">[</span><span class="n">coord</span><span class="o">.</span><span class="n">name</span><span class="p">()</span> <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">cube1</span><span class="o">.</span><span class="n">coords</span><span class="p">()]</span>
    <span class="n">coord_names2</span> <span class="o">=</span> <span class="p">[</span><span class="n">coord</span><span class="o">.</span><span class="n">name</span><span class="p">()</span> <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">cube2</span><span class="o">.</span><span class="n">coords</span><span class="p">()]</span>
    <span class="n">diff_coords1</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">coord_names1</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">coord_names2</span><span class="p">))</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Coordinates in first cube not present in second cube: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">diff_coords1</span><span class="p">))</span>

    <span class="n">diff_coords2</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">coord_names2</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">coord_names1</span><span class="p">))</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Coordinates in second cube not present in first cube: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">diff_coords2</span><span class="p">))</span>

    <span class="c1"># Copy cubes to ensure that time coordinate creation does not break filtering into time chunks.</span>
    <span class="n">cube1</span> <span class="o">=</span> <span class="n">_deepcopy_cube_if_no_time_coord</span><span class="p">(</span><span class="n">cube1</span><span class="p">)</span>
    <span class="n">cube2</span> <span class="o">=</span> <span class="n">_deepcopy_cube_if_no_time_coord</span><span class="p">(</span><span class="n">cube2</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">coord_name</span> <span class="ow">in</span> <span class="n">diff_coords1</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Adding &quot;</span><span class="si">{}</span><span class="s1">&quot; to second cube&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">coord_name</span><span class="p">))</span>
        <span class="n">cube2</span><span class="o">.</span><span class="n">add_aux_coord</span><span class="p">(</span><span class="n">cube1</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="n">coord_name</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">coord_name</span> <span class="ow">in</span> <span class="n">diff_coords2</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Adding &quot;</span><span class="si">{}</span><span class="s1">&quot; to first cube&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">coord_name</span><span class="p">))</span>
        <span class="n">cube1</span><span class="o">.</span><span class="n">add_aux_coord</span><span class="p">(</span><span class="n">cube2</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="n">coord_name</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">cube1</span><span class="p">,</span> <span class="n">cube2</span>


<span class="k">def</span> <span class="nf">_deepcopy_cube_if_no_time_coord</span><span class="p">(</span><span class="n">cube</span><span class="p">):</span>
    <span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">cube</span><span class="o">.</span><span class="n">coords</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Time coord not found. Copying cube&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cube</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">cube</span>


<div class="viewcode-block" id="divide_by_mask"><a class="viewcode-back" href="../../../mip_convert/process/processors.html#mip_convert.process.processors.divide_by_mask">[docs]</a><span class="k">def</span> <span class="nf">divide_by_mask</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="n">weights_cube</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Correct the tau pseudo level coordinate data in the supplied cube</span>
<span class="sd">    and then divide by the weights cube.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cube: :class:`iris.cube.Cube`</span>
<span class="sd">        Data variable cube.</span>
<span class="sd">    weights_cube: :class:`iris.cube.Cube`</span>
<span class="sd">        Weights variable cube.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    :class:`iris.cube.Cube`</span>
<span class="sd">        A cube with corrected tau pseudo level coordinate data with</span>
<span class="sd">        weights applied.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">divide_cubes</span><span class="p">(</span><span class="n">tau_pseudo_level</span><span class="p">(</span><span class="n">cube</span><span class="p">),</span> <span class="n">weights_cube</span><span class="p">)</span></div>


<div class="viewcode-block" id="jpdftaure_divide_by_mask"><a class="viewcode-back" href="../../../mip_convert/process/processors.html#mip_convert.process.processors.jpdftaure_divide_by_mask">[docs]</a><span class="k">def</span> <span class="nf">jpdftaure_divide_by_mask</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="n">weights_cube</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Correct the tau pseudo level coordinate data in the supplied cube</span>
<span class="sd">    and then divide by the weights cube. Also set the units of the</span>
<span class="sd">    &quot;height&quot; coordinate (really the &quot;radius&quot; axis) to &quot;micron&quot; and</span>
<span class="sd">    adds bounds. Note that the bounds values are hard coded into</span>
<span class="sd">    a set of constants.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cube: :class:`iris.cube.Cube`</span>
<span class="sd">        Data variable cube.</span>
<span class="sd">    weights_cube: :class:`iris.cube.Cube`</span>
<span class="sd">        Weights variable cube.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    :class:`iris.cube.Cube`</span>
<span class="sd">        A cube with corrected tau pseudo level coordinate data with</span>
<span class="sd">        weights applied.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    RuntimeError</span>
<span class="sd">        If the points on the height coordinate do not match the expected</span>
<span class="sd">        sets (JPDFTUAREICEMODIS_POINTS or JPDFTAURELIQMODIS_POINTS) at</span>
<span class="sd">        which point it is not clear how to proceed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">divide_by_mask</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="n">weights_cube</span><span class="p">)</span>
    <span class="n">result</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="s1">&#39;height&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="s1">&#39;micron&#39;</span>
    <span class="c1"># Add height bounds</span>
    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="s1">&#39;height&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">points</span> <span class="o">==</span> <span class="n">JPDFTAUREICEMODIS_POINTS</span><span class="p">):</span>
        <span class="n">result</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="s1">&#39;height&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="n">JPDFTAUREICEMODIS_BOUNDS</span>
    <span class="k">elif</span> <span class="nb">all</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="s1">&#39;height&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">points</span> <span class="o">==</span> <span class="n">JPDFTAURELIQMODIS_POINTS</span><span class="p">):</span>
        <span class="n">result</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="s1">&#39;height&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="n">JPDFTAURELIQMODIS_BOUNDS</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Could not work out bounds for height coordinate&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="fix_clmisr_height"><a class="viewcode-back" href="../../../mip_convert/process/processors.html#mip_convert.process.processors.fix_clmisr_height">[docs]</a><span class="k">def</span> <span class="nf">fix_clmisr_height</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="n">weights_cube</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Correct the height coordinate data to reflect the alt16 requested altitudes for</span>
<span class="sd">    the clmisr variables.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cube: :class:`iris.cube.Cube`</span>
<span class="sd">        Data variable cube.</span>
<span class="sd">    weights_cube: :class:`iris.cube.Cube`</span>
<span class="sd">        Weights variable cube.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    :class:&#39;iris.cube.Cube`</span>
<span class="sd">        Data variable cube with fixed height coords.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># The correct altitude values as specified by the data request.</span>
    <span class="n">fixed_altitudes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">250</span><span class="p">,</span> <span class="mi">750</span><span class="p">,</span> <span class="mi">1250</span><span class="p">,</span> <span class="mi">1750</span><span class="p">,</span> <span class="mi">2250</span><span class="p">,</span> <span class="mi">2750</span><span class="p">,</span> <span class="mi">3500</span><span class="p">,</span>
                                <span class="mi">4500</span><span class="p">,</span> <span class="mi">6000</span><span class="p">,</span> <span class="mi">8000</span><span class="p">,</span> <span class="mi">10000</span><span class="p">,</span> <span class="mi">12000</span><span class="p">,</span> <span class="mi">14500</span><span class="p">,</span>
                                <span class="mi">16000</span><span class="p">,</span> <span class="mi">18000</span><span class="p">))</span>
    <span class="c1"># Check if the STASH code of the cube is for the clmisr variable and</span>
    <span class="c1"># replace the height coords if True</span>
    <span class="n">stash</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="s1">&#39;STASH&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">stash</span> <span class="o">==</span> <span class="s1">&#39;m01s02i360&#39;</span><span class="p">:</span>
        <span class="n">height</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="s1">&#39;height&#39;</span><span class="p">)</span>
        <span class="n">height</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">fixed_altitudes</span>

    <span class="k">return</span> <span class="n">divide_cubes</span><span class="p">(</span><span class="n">tau_pseudo_level</span><span class="p">(</span><span class="n">cube</span><span class="p">),</span> <span class="n">weights_cube</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_finalize_lut_cube</span><span class="p">(</span><span class="n">cube</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The data on Land Use Tiles needs some final processing:</span>
<span class="sd">    1) the tiles must be in a specific order</span>
<span class="sd">    2) all tiles must be pressent</span>
<span class="sd">    3) the tile names need to be added</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Remove the unused pseudo_level coordinate</span>
    <span class="n">cube</span><span class="o">.</span><span class="n">remove_coord</span><span class="p">(</span><span class="s1">&#39;pseudo_level&#39;</span><span class="p">)</span>

    <span class="c1"># The lut coordinate is created by mapping the pseudo level values to</span>
    <span class="c1"># specific labels and then aggregating over that dimension. This means that</span>
    <span class="c1"># the lut cooridnate values are not necessarily in monotonically increasing</span>
    <span class="c1"># order, which necessary for the coordinate to become a dimension</span>
    <span class="c1"># coordinate. Splitting the cube into slices over the lut coordinate and</span>
    <span class="c1"># then merging the resulting cube list ensures the coordinate is correctly</span>
    <span class="c1"># ordered so that it can be promoted from an auxillary coordinate to a</span>
    <span class="c1"># dimension coordinate.</span>
    <span class="n">cube</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">cube</span><span class="o">.</span><span class="n">CubeList</span><span class="p">(</span><span class="n">cube</span><span class="o">.</span><span class="n">slices_over</span><span class="p">(</span><span class="s1">&#39;lut&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">merge_cube</span><span class="p">()</span>

    <span class="c1"># Make the &quot;lut&quot; coordinate the primary coordinate for that axis.</span>
    <span class="c1"># This may be needed for concatenation.</span>
    <span class="n">iris</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">promote_aux_coord_to_dim_coord</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="s1">&#39;lut&#39;</span><span class="p">)</span>

    <span class="c1"># Add the missing land use tiles.</span>
    <span class="n">lut_dim</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="s2">&quot;lut&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">points</span>
    <span class="n">cubes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">lut</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">lut</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lut_dim</span><span class="p">:</span>
            <span class="n">new_cube</span> <span class="o">=</span> <span class="n">cube</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">new_cube</span><span class="o">.</span><span class="n">data</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked</span>
            <span class="n">new_cube</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="s2">&quot;lut&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">lut</span>
            <span class="n">cubes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_cube</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">i</span><span class="p">,</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">lut_dim</span> <span class="o">==</span> <span class="n">lut</span><span class="p">)</span>
            <span class="n">cubes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cube</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
    <span class="n">cube</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">cube</span><span class="o">.</span><span class="n">CubeList</span><span class="p">(</span><span class="n">cubes</span><span class="p">)</span><span class="o">.</span><span class="n">concatenate_cube</span><span class="p">()</span>

    <span class="c1"># Label each UM land surface tile with a CMIP &quot;Land Use Tile&quot; name.</span>
    <span class="n">add_categorised_coord</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="s1">&#39;landUse&#39;</span><span class="p">,</span> <span class="s1">&#39;lut&#39;</span><span class="p">,</span> <span class="n">_lut_area_type</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cube</span>


<span class="k">def</span> <span class="nf">_lut_area_type</span><span class="p">(</span><span class="n">coordinate</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adds land use tile names as an auxiliary coordinate.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lookup</span> <span class="o">=</span> <span class="p">{</span>
        <span class="mi">0</span><span class="p">:</span> <span class="s2">&quot;primary_and_secondary_land&quot;</span><span class="p">,</span>
        <span class="mi">1</span><span class="p">:</span> <span class="s2">&quot;crops&quot;</span><span class="p">,</span>
        <span class="mi">2</span><span class="p">:</span> <span class="s2">&quot;pastures&quot;</span><span class="p">,</span>
        <span class="mi">3</span><span class="p">:</span> <span class="s2">&quot;urban&quot;</span><span class="p">,</span>
        <span class="o">-</span><span class="mi">999</span><span class="p">:</span> <span class="s2">&quot;&quot;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">lookup</span><span class="p">[</span><span class="n">value</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_lut_categorisation</span><span class="p">(</span><span class="n">coordinate</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reads in a UM/JULES tile ID and returns a CMIP6/LUMIP land use type number</span>
<span class="sd">    psl=natural=0, crp=crop=1, pst=pasture=2, urb=urban=3</span>

<span class="sd">    &gt;&gt;&gt; _lut_categorisation(None, 1)</span>
<span class="sd">    0</span>
<span class="sd">    &gt;&gt;&gt; _lut_categorisation(None, 301)</span>
<span class="sd">    1</span>
<span class="sd">    &gt;&gt;&gt; _lut_categorisation(None, 402)</span>
<span class="sd">    2</span>
<span class="sd">    &gt;&gt;&gt; _lut_categorisation(None, 6)</span>
<span class="sd">    3</span>
<span class="sd">    &gt;&gt;&gt; _lut_categorisation(None, 9)</span>
<span class="sd">    -999</span>

<span class="sd">    Unrecognized UM/JULES tile ids are given a CMIP6/LUMIP land use type None</span>

<span class="sd">    Calculate CMIP6 diagnostics on &#39;Land Use Types&#39; from UM outputs</span>
<span class="sd">    Land Use Types are defined by the LUMIP paper</span>
<span class="sd">    Lawrence et al, 2016. Geosci. Model Dev. Discuss., doi:10.5194/gmd-2016-76</span>
<span class="sd">    &#39;The Land Use Model Intercomparison Project (LUMIP): Rationale and experimental design&#39;</span>
<span class="sd">    CMIP6 diagnostics on Land Use Types generally end in &#39;Lut&#39;</span>
<span class="sd">    There are four Land Use Types in this explicit order:</span>
<span class="sd">    primary and secondary land (psl), cropland (crp), pastureland (pst) and urban (urb)</span>
<span class="sd">    Our interpretation is that psl=natural PFTs, crp=crop PFTs, pst=pasture PFTs, urb=urban tile</span>
<span class="sd">    Note that, using this interpretation, bare soil, lakes and ice are not included.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lut_ids</span> <span class="o">=</span> <span class="p">{</span>
        <span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">101</span><span class="p">,</span> <span class="mi">102</span><span class="p">,</span> <span class="mi">103</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">201</span><span class="p">,</span> <span class="mi">202</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">501</span><span class="p">,</span> <span class="mi">502</span><span class="p">],</span>
        <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">301</span><span class="p">,</span> <span class="mi">401</span><span class="p">],</span>
        <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">302</span><span class="p">,</span> <span class="mi">402</span><span class="p">],</span>
        <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">6</span><span class="p">]</span>
    <span class="p">}</span>
    <span class="n">lookup</span> <span class="o">=</span> <span class="p">{</span><span class="n">value</span><span class="p">:</span> <span class="o">-</span><span class="mi">999</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">lut</span><span class="p">,</span> <span class="n">um_ids</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">lut_ids</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
        <span class="n">lookup</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">um_id</span><span class="p">:</span> <span class="n">lut</span> <span class="k">for</span> <span class="n">um_id</span> <span class="ow">in</span> <span class="n">um_ids</span><span class="p">})</span>
    <span class="k">return</span> <span class="n">lookup</span><span class="p">[</span><span class="n">value</span><span class="p">]</span>


<div class="viewcode-block" id="calc_fgdms"><a class="viewcode-back" href="../../../mip_convert/process/processors.html#mip_convert.process.processors.calc_fgdms">[docs]</a><span class="k">def</span> <span class="nf">calc_fgdms</span><span class="p">(</span><span class="n">land_fraction</span><span class="p">,</span> <span class="n">cube</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the ``fgdms`` diagnostic by masking out land grid points</span>
<span class="sd">    from Atmos-surface-DMS emissions. Uses the land_fraction</span>
<span class="sd">    field in a inverse manner i.e. masks where land_fraction == 1.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    land_fraction : :class:`iris.cube.Cube`</span>
<span class="sd">        Land fraction cube.</span>
<span class="sd">    cube : :class:`iris.cube.Cube`</span>
<span class="sd">        DMS emissions as mol m-2 s-1</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    : :class:`iris.cube.Cube`</span>
<span class="sd">        DMS emissions with land cells masked out</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    RuntimeError</span>
<span class="sd">        If cube long, lat dimensions do not match land fraction.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Check that the input cube and land fraction dimensions match</span>
    <span class="k">if</span> <span class="n">cube</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">land_fraction</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Field and Land Fraction dimensions differ&#39;</span><span class="p">)</span>

    <span class="c1"># Apply a mask where land_frac=1 (keep sea+coastal points)</span>
    <span class="n">lf_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">land_fraction</span><span class="o">.</span><span class="n">data</span> <span class="o">==</span> <span class="mf">1.</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cube</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">cube</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">(</span><span class="n">cube</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="o">...</span><span class="p">])</span>
        <span class="n">cube</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">lf_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked</span>
    <span class="k">return</span> <span class="n">cube</span></div>


<div class="viewcode-block" id="remove_altitude_coords"><a class="viewcode-back" href="../../../mip_convert/process/processors.html#mip_convert.process.processors.remove_altitude_coords">[docs]</a><span class="k">def</span> <span class="nf">remove_altitude_coords</span><span class="p">(</span><span class="n">cube</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a cube with the altitude-related coordinates removed.</span>

<span class="sd">    This enables arithmetic to be performed between cubes, where one</span>
<span class="sd">    cube was created by selecting a single level from hybrid height</span>
<span class="sd">    levels.</span>

<span class="sd">    This processor also removes the ``HybridHeightFactory`` from the</span>
<span class="sd">    cube, see https://scitools.org.uk/iris/docs/latest/whitepapers/\</span>
<span class="sd">    um_files_loading.html#vertical-coordinates for more details.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cube: :class:`iris.cube.Cube`</span>
<span class="sd">        A cube containing altitude-related coordinates.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    : :class:`iris.cube.Cube`</span>
<span class="sd">        A cube with the altitude-related coordinates removed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">cube</span><span class="o">.</span><span class="n">remove_aux_factory</span><span class="p">(</span><span class="n">cube</span><span class="o">.</span><span class="n">aux_factory</span><span class="p">())</span>
    <span class="k">except</span> <span class="n">CoordinateNotFoundError</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Cannot remove non-existent aux factory from cube &quot;</span><span class="si">{}</span><span class="s1">&quot;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">cube</span><span class="p">)))</span>
    <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">cube</span><span class="o">.</span><span class="n">coords</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">coord</span><span class="o">.</span><span class="n">name</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;surface_altitude&#39;</span><span class="p">:</span>
            <span class="n">cube</span><span class="o">.</span><span class="n">remove_coord</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cube</span></div>


<div class="viewcode-block" id="mask_polar_column_zonal_means"><a class="viewcode-back" href="../../../mip_convert/process/processors.html#mip_convert.process.processors.mask_polar_column_zonal_means">[docs]</a><span class="k">def</span> <span class="nf">mask_polar_column_zonal_means</span><span class="p">(</span><span class="n">cube_data</span><span class="p">,</span> <span class="n">cube_heaviside</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a cube with the columns corresponding to the north and south</span>
<span class="sd">    poles masked out to avoid publishing erroneous data. This is only</span>
<span class="sd">    intended for the correction of zonal mean diagnostics</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cube_data: :class:`iris.cube.Cube`</span>
<span class="sd">        A cube containing zonal mean data</span>
<span class="sd">    cube_heaviside: :class:`iris.cube.Cube`</span>
<span class="sd">        A cube containing zonal mean heaviside data</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    : :class:`iris.cube.Cube`</span>
<span class="sd">        A cube with the polar columns masked.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    RuntimeError</span>
<span class="sd">        If unable to construct a mask cube.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cube</span> <span class="o">=</span> <span class="n">zonal_apply_heaviside</span><span class="p">(</span><span class="n">cube_data</span><span class="p">,</span> <span class="n">cube_heaviside</span><span class="p">)</span>
    <span class="c1"># Get first time slice of cube for use as mask</span>
    <span class="n">mask_cube</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">cube</span><span class="o">.</span><span class="n">slices_over</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">))</span>
    <span class="c1"># Remove time coordinate</span>
    <span class="n">mask_cube</span><span class="o">.</span><span class="n">remove_coord</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">)</span>
    <span class="c1"># Convert mask_cube data to masked array with ones everywhere</span>
    <span class="n">mask_cube</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">mask_cube</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="n">mask</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># Construct slices for polar columns.</span>
    <span class="k">if</span> <span class="n">mask_cube</span><span class="o">.</span><span class="n">coord_dims</span><span class="p">(</span><span class="s1">&#39;latitude&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,):</span>
        <span class="n">s_slice</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">n_slice</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">mask_cube</span><span class="o">.</span><span class="n">coord_dims</span><span class="p">(</span><span class="s1">&#39;latitude&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">0</span><span class="p">,):</span>
        <span class="n">s_slice</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">n_slice</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Could not identify latitude coordinate when attempting to construct mask&#39;</span><span class="p">)</span>

    <span class="c1"># Mask polar columns</span>
    <span class="n">mask_cube</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="n">s_slice</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">mask_cube</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="n">n_slice</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># return product of original cube and the mask cube.</span>
    <span class="k">return</span> <span class="n">cube</span> <span class="o">*</span> <span class="n">mask_cube</span></div>


<div class="viewcode-block" id="hotspot"><a class="viewcode-back" href="../../../mip_convert/process/processors.html#mip_convert.process.processors.hotspot">[docs]</a><span class="k">def</span> <span class="nf">hotspot</span><span class="p">(</span><span class="n">upward_lw_flux</span><span class="p">,</span> <span class="n">olr_s3</span><span class="p">,</span> <span class="n">olr_s2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a cube with adjusted time-mean GCM upward LW flux using the</span>
<span class="sd">    difference between the OLRs diagnosed by Sections 3 &amp; 2.</span>

<span class="sd">    The &quot;hotspot&quot; code in the GCM surface scheme re-calculates the</span>
<span class="sd">    upward surface LW flux every physics timestep, avoiding instability</span>
<span class="sd">    by providing immediate feedback on surface temperature without</span>
<span class="sd">    waiting for radiation timesteps, but making the surface energy</span>
<span class="sd">    budget inconsistent with the LW scheme&#39;s calculations.</span>
<span class="sd">    For CMIP we shall make everything consistent by adjusting upward</span>
<span class="sd">    &amp; net LW fluxes from the LW scheme by the difference between the</span>
<span class="sd">    OLRs diagnosed by the 2 schemes.</span>
<span class="sd">    For single-level outputs this can be done by the standard</span>
<span class="sd">    processing, but not multi-level ones, so this function is needed.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    upward_lw_flux: :class:`iris.cube.Cube`</span>
<span class="sd">        The upward LW flux to be adjusted.</span>

<span class="sd">    olr_s3: :class:`iris.cube.Cube`</span>
<span class="sd">        The OLR (rlut) from Section 3 (item 332), consistent with the</span>
<span class="sd">        surface scheme.</span>

<span class="sd">    olr_s2: :class:`iris.cube.Cube`</span>
<span class="sd">        The OLR (rlut) from Section 2 (item 205), consistent with the</span>
<span class="sd">        LW scheme.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    : :class:`iris.cube.Cube`</span>
<span class="sd">        The adjusted upward LW flux.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># The next line assumes that the OLR cubes have time, latitude &amp; longitude axes only, &amp;</span>
    <span class="c1"># the multilevel ones these plus height as &quot;1st&quot; dimension, as is true for MO CMIP6 data.</span>
    <span class="n">upward_lw_flux</span><span class="o">.</span><span class="n">data</span> <span class="o">+=</span> <span class="n">iris</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">broadcast_to_shape</span><span class="p">((</span><span class="n">olr_s3</span> <span class="o">-</span> <span class="n">olr_s2</span><span class="p">)</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">upward_lw_flux</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

    <span class="c1"># All these multilevel fields will have the metadata error that correct_multilevel_metadata corrects,</span>
    <span class="c1"># so it&#39;s simplest to apply that here too.</span>
    <span class="n">upward_lw_flux</span> <span class="o">=</span> <span class="n">correct_multilevel_metadata</span><span class="p">(</span><span class="n">upward_lw_flux</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">upward_lw_flux</span></div>


<div class="viewcode-block" id="correct_multilevel_metadata"><a class="viewcode-back" href="../../../mip_convert/process/processors.html#mip_convert.process.processors.correct_multilevel_metadata">[docs]</a><span class="k">def</span> <span class="nf">correct_multilevel_metadata</span><span class="p">(</span><span class="n">cube</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a cube with corrected level metadata for multi-level fluxes</span>
<span class="sd">    between theta levels.</span>

<span class="sd">    Since New Dynamics was introduced STASH has given them metadata</span>
<span class="sd">    appropriate for rho-level quantities, so labelling the lowest one</span>
<span class="sd">    as at the lowest rho level when it is in fact at the surface, and</span>
<span class="sd">    setting bounds (to the theta levels), when they should have none.</span>
<span class="sd">    This affects all radiative fluxes requested by CMIP on atmospheric</span>
<span class="sd">    levels, and also a few requested at the surface or top of</span>
<span class="sd">    atmosphere that have to be obtained as the top or bottom layer of a</span>
<span class="sd">    multi-level STASH diagnostic.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cube: :class:`iris.cube.Cube`</span>
<span class="sd">        Any cube of a flux between theta levels.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    : :class:`iris.cube.Cube`</span>
<span class="sd">        The same cube but with corrected levels metadata.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># The coordinates in order will be:</span>
    <span class="c1"># &#39;time&#39;, &#39;atmosphere_hybrid_height_coordinate&#39;, &#39;latitude&#39;, &#39;longitude&#39;, &#39;vertical coordinate formula term:</span>
    <span class="c1"># b(k)&#39;, &#39;Surface Altitude&#39;, &#39;altitude&#39; (all standard_name apart from 4 &amp; 5 whose standard_name is None).</span>
    <span class="c1"># 6 / &#39;altitude&#39; has both errors, but is derived from the other coordinates, not saved in the output file &amp;</span>
    <span class="c1"># automatically changes with height, so needs no action.</span>

    <span class="c1"># Check whether there is a surface level to apply the surface corrections to.</span>
    <span class="c1"># It will be the 1st level if present, but maybe only toa is.</span>
    <span class="k">if</span> <span class="mf">1.</span> <span class="o">&lt;</span> <span class="n">cube</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="s1">&#39;level_height&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">:</span>
        <span class="c1"># This can be done only by re-setting the whole array.</span>
        <span class="n">correct_heights</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="s1">&#39;level_height&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">correct_heights</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="n">cube</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="s1">&#39;level_height&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">correct_heights</span>

        <span class="c1">#  ...though there is no such protection for this bit:</span>
        <span class="n">cube</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="s1">&#39;sigma&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>

    <span class="c1"># Physically there are no bounds in the vertical in the sense that the values apply solely at the level specified,</span>
    <span class="c1"># so let&#39;s remove them.</span>
    <span class="n">cube</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="s1">&#39;level_height&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="n">cube</span></div>


<div class="viewcode-block" id="mask_vtem"><a class="viewcode-back" href="../../../mip_convert/process/processors.html#mip_convert.process.processors.mask_vtem">[docs]</a><span class="k">def</span> <span class="nf">mask_vtem</span><span class="p">(</span><span class="n">cube_vtem</span><span class="p">,</span> <span class="n">cube_heaviside</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a cube with all data at and below 700 hPa masked out.</span>
<span class="sd">    Note that the vtem data is produced as a zonal mean, while the</span>
<span class="sd">    zonal meaning is done by STASH in the UM. They end up with</span>
<span class="sd">    slightly different scalar longitude coordinates, so some</span>
<span class="sd">    unification is required. Here we choose to put the points</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cube_vtem : :class:`iris.cube.Cube`</span>
<span class="sd">        vtem cube to mask.</span>
<span class="sd">    cube_heaviside : :class:`iris.cube.Cube`</span>
<span class="sd">        Heaviside data</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    :class:`iris.cube.Cube`</span>
<span class="sd">        Masked cube.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cube</span> <span class="o">=</span> <span class="n">zonal_apply_heaviside</span><span class="p">(</span><span class="n">cube_vtem</span><span class="p">,</span> <span class="n">cube_heaviside</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_mask_plev_cube</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="mi">1100</span><span class="p">,</span> <span class="mi">700</span><span class="p">)</span></div>


<div class="viewcode-block" id="zonal_apply_heaviside"><a class="viewcode-back" href="../../../mip_convert/process/processors.html#mip_convert.process.processors.zonal_apply_heaviside">[docs]</a><span class="k">def</span> <span class="nf">zonal_apply_heaviside</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="n">cube_heaviside</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply the Heaviside field to zonal mean variables after</span>
<span class="sd">    fixing the longitude coordinate</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cube : :class:`iris.cube.Cube`</span>
<span class="sd">        data</span>
<span class="sd">    cube_heaviside : :class:`iris.cube.Cube`</span>
<span class="sd">        Heaviside data</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    :class:`iris.cube.Cube`</span>
<span class="sd">        scaled data</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">_recentre_coord_bounds</span><span class="p">(</span><span class="n">coord</span><span class="p">):</span>
        <span class="n">coord</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="p">(</span><span class="n">coord</span><span class="o">.</span><span class="n">bounds</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">coord</span><span class="o">.</span><span class="n">bounds</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="n">_recentre_coord_bounds</span><span class="p">(</span><span class="n">cube</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="s1">&#39;longitude&#39;</span><span class="p">))</span>
    <span class="n">_recentre_coord_bounds</span><span class="p">(</span><span class="n">cube_heaviside</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="s1">&#39;longitude&#39;</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">cube</span> <span class="o">/</span> <span class="n">cube_heaviside</span></div>


<div class="viewcode-block" id="mean_diurnal_cycle"><a class="viewcode-back" href="../../../mip_convert/process/processors.html#mip_convert.process.processors.mean_diurnal_cycle">[docs]</a><span class="k">def</span> <span class="nf">mean_diurnal_cycle</span><span class="p">(</span><span class="n">cube</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the monthly mean diurnal cycle. It averages all</span>
<span class="sd">    the fields within the same hour for each month. The output</span>
<span class="sd">    will contain 24 fields for each month.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cube: :class:`iris.cube.Cube`</span>
<span class="sd">        A cube with hourly means or higher-frequency data.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    : :class:`iris.cube.Cube`</span>
<span class="sd">        A cube with a monthly-mean hourly time series.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">add_year</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;year&#39;</span><span class="p">)</span>
    <span class="n">add_month_number</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;month&#39;</span><span class="p">)</span>
    <span class="n">add_hour</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;hour&#39;</span><span class="p">)</span>
    <span class="n">cube</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">aggregated_by</span><span class="p">([</span><span class="s1">&#39;year&#39;</span><span class="p">,</span> <span class="s1">&#39;month&#39;</span><span class="p">,</span> <span class="s1">&#39;hour&#39;</span><span class="p">],</span> <span class="n">MEAN</span><span class="p">)</span>
    <span class="c1"># Correction of time coordinate. Subtract 12 hours in the correct units.</span>
    <span class="n">date_time_1</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="mi">1900</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">date_time_2</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="mi">1900</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">time_coord</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">)</span>
    <span class="n">time_diff</span> <span class="o">=</span> <span class="n">time_coord</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">date2num</span><span class="p">(</span><span class="n">date_time_1</span><span class="p">)</span> <span class="o">-</span> <span class="n">time_coord</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">date2num</span><span class="p">(</span><span class="n">date_time_2</span><span class="p">)</span>
    <span class="n">cube</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">points</span> <span class="o">-</span> <span class="n">time_diff</span>
    <span class="k">return</span> <span class="n">cube</span></div>


<span class="k">def</span> <span class="nf">_mask_plev_cube</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="n">max_pressure_masked</span><span class="p">,</span> <span class="n">min_pressure_masked</span><span class="p">):</span>
    <span class="c1"># Construct a mask from the pressure coordinate data.</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_inside</span><span class="p">(</span><span class="n">cube</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="s1">&#39;pressure&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="n">min_pressure_masked</span><span class="p">,</span> <span class="n">max_pressure_masked</span><span class="p">)</span>
    <span class="n">mask</span><span class="o">.</span><span class="n">data</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">1.</span>

    <span class="c1"># Broadcast mask to the same shape as the cube</span>
    <span class="n">mask_broadcast</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">broadcast_to_shape</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">cube</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">cube</span><span class="o">.</span><span class="n">coord_dims</span><span class="p">(</span><span class="s1">&#39;pressure&#39;</span><span class="p">))</span>

    <span class="c1"># Apply mask.</span>
    <span class="n">cube</span><span class="o">.</span><span class="n">data</span> <span class="o">*=</span> <span class="n">mask_broadcast</span>
    <span class="k">return</span> <span class="n">cube</span>


<div class="viewcode-block" id="day_max"><a class="viewcode-back" href="../../../mip_convert/process/processors.html#mip_convert.process.processors.day_max">[docs]</a><span class="k">def</span> <span class="nf">day_max</span><span class="p">(</span><span class="n">cube</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the max daily value of the cube.&quot;&quot;&quot;</span>

    <span class="n">add_day_of_month</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;day&#39;</span><span class="p">)</span>
    <span class="n">add_month_number</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;month&#39;</span><span class="p">)</span>
    <span class="n">add_year</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;year&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">cube</span><span class="o">.</span><span class="n">aggregated_by</span><span class="p">([</span><span class="s1">&#39;day&#39;</span><span class="p">,</span> <span class="s1">&#39;month&#39;</span><span class="p">,</span> <span class="s1">&#39;year&#39;</span><span class="p">],</span> <span class="n">MAX</span><span class="p">)</span></div>


<div class="viewcode-block" id="avg_from_hourly"><a class="viewcode-back" href="../../../mip_convert/process/processors.html#mip_convert.process.processors.avg_from_hourly">[docs]</a><span class="k">def</span> <span class="nf">avg_from_hourly</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="n">period_in_hours</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the n-hour average of the cube &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_select_n_hourly_period</span><span class="p">(</span><span class="n">period_in_hours</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">_function</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
            <span class="n">date</span> <span class="o">=</span> <span class="n">coord</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">num2date</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">date</span><span class="o">.</span><span class="n">hour</span> <span class="o">//</span> <span class="n">period_in_hours</span>
        <span class="k">return</span> <span class="n">_function</span>

    <span class="n">select_averaging_period</span> <span class="o">=</span> <span class="n">_select_n_hourly_period</span><span class="p">(</span><span class="n">period_in_hours</span><span class="p">)</span>
    <span class="n">iris</span><span class="o">.</span><span class="n">coord_categorisation</span><span class="o">.</span><span class="n">add_categorised_coord</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="s2">&quot;hourly_period&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="n">select_averaging_period</span><span class="p">)</span>
    <span class="n">add_day_of_month</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;day&#39;</span><span class="p">)</span>
    <span class="n">add_month_number</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;month&#39;</span><span class="p">)</span>
    <span class="n">add_year</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;year&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cube</span><span class="o">.</span><span class="n">aggregated_by</span><span class="p">([</span><span class="s1">&#39;hourly_period&#39;</span><span class="p">,</span> <span class="s1">&#39;day&#39;</span><span class="p">,</span> <span class="s1">&#39;month&#39;</span><span class="p">,</span> <span class="s1">&#39;year&#39;</span><span class="p">],</span> <span class="n">MEAN</span><span class="p">)</span></div>


<div class="viewcode-block" id="extract_n_hourly"><a class="viewcode-back" href="../../../mip_convert/process/processors.html#mip_convert.process.processors.extract_n_hourly">[docs]</a><span class="k">def</span> <span class="nf">extract_n_hourly</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="n">period_in_hours</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Extract every &quot;period_in_hours&quot; from cube&quot;&quot;&quot;</span>

    <span class="n">hour_sequence</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="n">period_in_hours</span><span class="p">)</span>
    <span class="n">add_hour</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;hour&quot;</span><span class="p">)</span>
    <span class="n">nhourly</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">Constraint</span><span class="p">(</span><span class="n">hour</span><span class="o">=</span><span class="n">hour_sequence</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cube</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">nhourly</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">rotate_winds</span><span class="p">(</span><span class="n">cube_u</span><span class="p">,</span> <span class="n">cube_v</span><span class="p">):</span>
    <span class="n">target_cs</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">coord_systems</span><span class="o">.</span><span class="n">GeogCS</span><span class="p">(</span><span class="n">iris</span><span class="o">.</span><span class="n">fileformats</span><span class="o">.</span><span class="n">pp</span><span class="o">.</span><span class="n">EARTH_RADIUS</span><span class="p">)</span>
    <span class="n">rotated_cubes</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">cartography</span><span class="o">.</span><span class="n">rotate_winds</span><span class="p">(</span><span class="n">cube_u</span><span class="p">,</span> <span class="n">cube_v</span><span class="p">,</span> <span class="n">target_cs</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">cube</span> <span class="ow">in</span> <span class="n">rotated_cubes</span><span class="p">:</span>
        <span class="n">cube</span><span class="o">.</span><span class="n">remove_coord</span><span class="p">(</span><span class="s1">&#39;projection_x_coordinate&#39;</span><span class="p">)</span>
        <span class="n">cube</span><span class="o">.</span><span class="n">remove_coord</span><span class="p">(</span><span class="s1">&#39;projection_y_coordinate&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">rotated_cubes</span>


<div class="viewcode-block" id="urot_calc"><a class="viewcode-back" href="../../../mip_convert/process/processors.html#mip_convert.process.processors.urot_calc">[docs]</a><span class="k">def</span> <span class="nf">urot_calc</span><span class="p">(</span><span class="n">cube_u</span><span class="p">,</span> <span class="n">cube_v</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate the u component with respect to the standard lon-lat system &quot;&quot;&quot;</span>

    <span class="n">cube_u_prime</span><span class="p">,</span> <span class="n">cube_v_prime</span> <span class="o">=</span> <span class="n">rotate_winds</span><span class="p">(</span><span class="n">cube_u</span><span class="p">,</span> <span class="n">cube_v</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">cube_u_prime</span></div>


<div class="viewcode-block" id="vrot_calc"><a class="viewcode-back" href="../../../mip_convert/process/processors.html#mip_convert.process.processors.vrot_calc">[docs]</a><span class="k">def</span> <span class="nf">vrot_calc</span><span class="p">(</span><span class="n">cube_u</span><span class="p">,</span> <span class="n">cube_v</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate the v component with respect to the standard lon-lat system &quot;&quot;&quot;</span>
    <span class="n">cube_u_prime</span><span class="p">,</span> <span class="n">cube_v_prime</span> <span class="o">=</span> <span class="n">rotate_winds</span><span class="p">(</span><span class="n">cube_u</span><span class="p">,</span> <span class="n">cube_v</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">cube_v_prime</span></div>


<div class="viewcode-block" id="urot_calc_extract_n_hourly"><a class="viewcode-back" href="../../../mip_convert/process/processors.html#mip_convert.process.processors.urot_calc_extract_n_hourly">[docs]</a><span class="k">def</span> <span class="nf">urot_calc_extract_n_hourly</span><span class="p">(</span><span class="n">cube_u</span><span class="p">,</span> <span class="n">cube_v</span><span class="p">,</span> <span class="n">period_in_hours</span><span class="o">=</span><span class="mi">6</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Extract 6-hourly winds and calculate the u component with respect to the standard lon-lat system &quot;&quot;&quot;</span>

    <span class="n">cube_u</span> <span class="o">=</span> <span class="n">extract_n_hourly</span><span class="p">(</span><span class="n">cube_u</span><span class="p">,</span> <span class="n">period_in_hours</span><span class="p">)</span>
    <span class="n">cube_v</span> <span class="o">=</span> <span class="n">extract_n_hourly</span><span class="p">(</span><span class="n">cube_v</span><span class="p">,</span> <span class="n">period_in_hours</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">urot_calc</span><span class="p">(</span><span class="n">cube_u</span><span class="p">,</span> <span class="n">cube_v</span><span class="p">)</span></div>


<div class="viewcode-block" id="vrot_calc_extract_n_hourly"><a class="viewcode-back" href="../../../mip_convert/process/processors.html#mip_convert.process.processors.vrot_calc_extract_n_hourly">[docs]</a><span class="k">def</span> <span class="nf">vrot_calc_extract_n_hourly</span><span class="p">(</span><span class="n">cube_u</span><span class="p">,</span> <span class="n">cube_v</span><span class="p">,</span> <span class="n">period_in_hours</span><span class="o">=</span><span class="mi">6</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Extract 6-hourly winds and calculate the v component with respect to the standard lon-lat system &quot;&quot;&quot;</span>

    <span class="n">cube_u</span> <span class="o">=</span> <span class="n">extract_n_hourly</span><span class="p">(</span><span class="n">cube_u</span><span class="p">,</span> <span class="n">period_in_hours</span><span class="p">)</span>
    <span class="n">cube_v</span> <span class="o">=</span> <span class="n">extract_n_hourly</span><span class="p">(</span><span class="n">cube_v</span><span class="p">,</span> <span class="n">period_in_hours</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">vrot_calc</span><span class="p">(</span><span class="n">cube_u</span><span class="p">,</span> <span class="n">cube_v</span><span class="p">)</span></div>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">MIP Convert 2.4.5 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">mip_convert.process.processors</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright British Crown 2015-2022, Met Office.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.2.0.
    </div>
  </body>
</html>